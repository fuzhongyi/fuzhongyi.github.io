[{"title":"async/await 实现原理","date":"2020-05-29T09:56:43.000Z","path":"2020/05/29/async-await-realize/","text":"使用123456789101112var p1 = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Promisem 1'), 3000));var p2 = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Promisem 2'), 3000));async function test() &#123; var data1 = await p1(); console.log(data1); var data2 = await p2(); console.log(data2); return 'end';&#125;test().then(console.log); 实现123456789101112131415161718192021222324252627var p1 = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Promisem 1'), 3000));var p2 = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Promisem 2'), 3000));function* test() &#123; var data1 = yield p1(); console.log(data1); var data2 = yield p2(); console.log(data2); return 'end';&#125;function asyncToGenerator(gen) &#123; return new Promise((resolve, reject) =&gt; &#123; var g = gen.apply(this, Array.prototype.slice.call(arguments, 1)); function step(val) &#123; var result = g.next(val); if (result.done) &#123; resolve(result.value); &#125; else &#123; Promise.resolve(result.value).then(step, reject); &#125; &#125; step(); &#125;);&#125;asyncToGenerator(test).then(console.log);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"async","slug":"async","permalink":"http://xyue.me/tags/async/"}]},{"title":"一文看尽 redux，中间件设计实现","date":"2020-04-15T09:30:57.000Z","path":"2020/04/15/react-redux-middleware/","text":"reduxReact 作为一个组件化开发框架，组件之间存在大量通信，有时这些通信跨越多个组件，或者多个组件之间共享一套数据，简单的父子组件间传值不能满足我们的需求，自然而然地，我们需要有一个地方存取和操作这些公共状态。而 redux 就为我们提供了这样一种管理公共状态的方案。 了解了什么是 redux，以及它的到来为我们解决了什么问题，我们围绕这一功能，逐步实现。 既然是公共状态，那么我们创建这样一个文件 store.js，然后直接在里边存放公共的 state，其他组件只要引入这个 store 就可以存取共用状态了。 123export const state = &#123; count: 0&#125; 当然我们并不能这样去设计，主要原因有 2 点： 容易误操作 - 其他任何地方均可以修改 state，这样做显然不太安全 出错了也很难排查，因此我们需要有条件地操作 store，防止使用者直接修改 store 的数据 可读性很差 - js 是一门极其依赖语义化的语言，试想如果在代码中不经注释直接修改了公用的 state，难以维护，为了搞清楚修改 state 的含义还得根据上下文推断，所以我们最好是给每个操作起个名字 思考： 我们希望公共状态既能够被全局访问到，又是私有的不能被直接修改，闭包完全满足这两条要求，因此我们会把公共状态设计成闭包。 既然我们要存取状态，那么肯定要有 getter 和 setter，此外当状态发生改变时，我们得进行广播，通知组件状态发生了变更。 这不就和 redux 的三个 api：getState、dispatch、subscribe 对应上了吗。 我们用几句代码勾勒出 store 的大致形状： 1234567export const createStore = () =&gt; &#123; let currentState = &#123;&#125; // 公共状态 function getState() &#123;&#125; // getter function dispatch() &#123;&#125; // setter function subscribe() &#123;&#125; // 发布订阅 return &#123; getState, dispatch, subscribe &#125;&#125; getState 实现getState() 的实现非常简单，返回当前状态即可： 123456789export const createStore = () =&gt; &#123; let currentState = &#123;&#125; // 公共状态 function getState() &#123; // getter return currentState; &#125; function dispatch() &#123;&#125; // setter function subscribe() &#123;&#125; // 发布订阅 return &#123; getState, dispatch, subscribe &#125;&#125; dispatch 实现经过上面的分析，我们的目标是有条件地、具名地修改 store 的数据。所以这里我们像 redux 中 dispatch 那样传入一个 action 对象，这个对象包含操作类型 type，根据 type 的不同对应修改返回不同的 state。 1234567891011121314151617export const createStore = () =&gt; &#123; let currentState = &#123;&#125; function getState() &#123; return currentState &#125; function dispatch(action) &#123; switch (action.type) &#123; case 'plus': currentState = &#123; ...state, count: currentState.count + 1 &#125; &#125; &#125; function subscribe() &#123;&#125; return &#123; getState, subscribe, dispatch &#125;&#125; 但是这样我们把执行逻辑写在了 dispatch 中，耦合度太高，于是我们想到把这部分代码抽离出来放到外面。 1234567891011export const createStore = (reducer) =&gt; &#123; let currentState = &#123;&#125; function getState() &#123; return currentState &#125; function dispatch(action) &#123; currentState = reducer(currentState, action) &#125; function subscribe() &#123;&#125; return &#123; getState, subscribe, dispatch &#125;&#125; 这不就是我们熟悉的 reducer 吗，然后我们创建一个 reducer.js 文件，写我们的 reducer。 12345678910111213141516171819const initialState = &#123; count: 0&#125;export function reducer(state = initialState, action) &#123; switch(action.type) &#123; case 'plus': return &#123; ...state, count: state.count + 1 &#125; case 'subtract': return &#123; ...state, count: state.count - 1 &#125; default: return initialState &#125;&#125; 代码写到这里，我们可以验证一下 getState 和 dispatch。 12345import &#123; reducer &#125; from './reducer'const store = createStore(reducer) // 创建storestore.dispatch(&#123; type: 'plus' &#125;) // 执行加法操作，给 count 加 1console.log(store.getState()) // 获取 state 运行代码，我们会发现，打印得到的 state 是：{ count: NaN }。这是因为，store 中 state 的初始数据为 {}， state.count + 1 实际上是 underfind + 1。 所以我们得先进行 state 数据的初始化： 123456789101112export const createStore = (reducer) =&gt; &#123; let currentState = &#123;&#125; function getState() &#123; return currentState &#125; function dispatch(action) &#123; currentState = reducer(currentState, action) &#125; dispatch(&#123;type:'@STATE_INIT@'&#125;); // 初始化 state 数据 function subscribe() &#123;&#125; return &#123; getState, subscribe, dispatch &#125;&#125; 这样我们就能得到正确的 state：{ count: 1 }。 subscribe 实现尽管我们已经能够存取公用 state，但 store 的变化并不会直接引起视图的更新，我们需要监听 store 的变化。每次 dispatch，都进行广播，通知组件 store 的状态发生了变更，这里我们应用一个设计模式——观察者模式。 123456789101112131415161718192021export const createStore = (reducer) =&gt; &#123; let currentState = &#123;&#125; let observers = [] // 观察者队列 function getState() &#123; return currentState &#125; function dispatch(action) &#123; currentState = reducer(currentState, action) observers.forEach(fn =&gt; fn()) &#125; dispatch(&#123;type:'@STATE_INIT@'&#125;); // 初始化 state 数据 function subscribe(fn) &#123; observers.push(fn) &#125; return &#123; getState, subscribe, dispatch &#125;&#125;const store = createStore(reducer) store.subscribe(() =&gt; &#123; console.log('组件 1 收到 store 的通知') &#125;)store.subscribe(() =&gt; &#123; console.log('组件 2 收到 store 的通知') &#125;)store.dispatch(&#123; type: 'plus' &#125;) // 执行 dispatch，触发 store 的通知 到这里，一个简单的 redux 就已经完成。 但我们在使用 store 时，需要在每个组件中 import 引入 store，然后获取状态(getState)，修改状态(dispatch) ，订阅更新(subscribe)，代码比较冗余，我们需要合并一些重复操作，而其中一种简化合并的方案，就是我们熟悉的 react-redux。 react-redux上文我们说到，一个组件如果想从 store 存取公用状态，需要进行四步操作。 react-redux 提供 Provider 和 connect 两个 API，Provider 将 store 放进 this.context 里，省去了 import 这一步，connect 将 getState、dispatch 合并进了 this.props，并自动订阅更新，简化了另外三步，下面我们来看一下如何实现这两个 API： Provider 实现Provider 是一个组件，接收 store 并将其放进全局 context。 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'export class Provider extends Component &#123; // 需要声明静态属性 childContextTypes 来指定 context 对象的属性，是 context 的固定写法 static childContextTypes = &#123; store: PropTypes.object &#125; // 实现 getChildContext 方法，返回 context 对象，也是固定写法 getChildContext() &#123; return &#123; store: this.store &#125; &#125; constructor(props, context) &#123; super(props, context) this.store = props.store &#125; // 渲染被 Provider 包裹的组件 render() &#123; return this.props.children &#125;&#125; 完成 Provider 后，我们就不需要再单独 import store，可直接在组件中通过 this.context.store 取到 store。 connect 实现下面我们来思考一下如何实现 connect，我们先回顾一下 connect 的使用方法： 1connect(mapStateToProps, mapDispatchToProps)(App) 我们知道，connect 接收 mapStateToProps、mapDispatchToProps 两个方法，然后返回一个高阶函数，这个高阶函数接收一个组件，返回一个高阶组件，其实目的就是给传入组件增加一些属性和功能，connect 根据传入的 mapStateToProps、mapDispatchToProps，将 state 和 dispatch(action) 挂载到子组件的 props 上： 12345678910111213141516171819202122232425262728293031323334import React from 'react'export function connect(mapStateToProps, mapDispatchToProps) &#123; return function(Component) &#123; class Connect extends React.Component &#123; componentDidMount() &#123; // 从 context 获取 store 并订阅更新 this.context.store.subscribe(this.handleStoreChange.bind(this)); &#125; handleStoreChange() &#123; // 触发更新 // 触发的方法有多种，这里为了简洁起见，直接 forceUpdate 强制更新，读者也可以通过 setState 来触发子组件更新 this.forceUpdate() &#125; render() &#123; return ( &lt;Component // 传入该组件的 props，需要由 connect 这个高阶组件原样传回原组件 &#123; ...this.props &#125; // 根据 mapStateToProps 把 state 挂到 this.props 上 &#123; ...mapStateToProps(this.context.store.getState()) &#125; // 根据 mapDispatchToProps 把 dispatch(action) 挂到 this.props 上 &#123; ...mapDispatchToProps(this.context.store.dispatch) &#125; /&gt; ) &#125; &#125; // 接收 context 的固定写法 Connect.contextTypes = &#123; store: PropTypes.object &#125; return Connect &#125;&#125; redux Middleware所谓中间件，我们可以理解为拦截器，用于对某些过程进行拦截和处理，且中间件之间能够串联使用。在 redux 中，我们中间件拦截的是 dispatch 提交到 reducer 这个过程，从而增强 dispatch 的功能。 可查阅官方文档。 接下来让我们和官方文档一样，以一个记录日志的中间件为例，一步一步分析 redux 中间件的设计实现。 在每次 dispatch 之后手动打印 store 的内容假如我们想在每次 dispatch 之后，打印一下 store 的内容，我们则会这样去实现： 12store.dispatch(&#123; type: 'plus' &#125;)console.log('next state', store.getState()) 这是最简单直接的实现方式，当然我们并不可能在项目每个 dispatch 的地方都添加这样一段代码，我们可以把这部分功能的代码提取出来。 封装 dispatch1234function patchStoreToAddLogging(store, action) &#123; store.dispatch(action) console.log('next state', store.getState())&#125; 这样可以减少一部分重复的代码。不过每次使用这个新的 dispatch 都得从外部引一下，依然没有解决增加不必要的业务代码。 所以我们得思考另外一种一劳永逸的方式，替换 dispatch： 替换 dispatch123456const next = store.dispatchstore.dispatch = function patchStoreToAddLogging(action) &#123; let result = next(action) console.log('next state', store.getState()) return result&#125; 这样我们每次使用的时候就不需要再从外部引用一次了。 但这样还是不够好的，试想一下，如果我们又有其他的需求，比方监控 dispatch 错误，我们固然可以在打印日志的代码后面加上捕获错误的代码，但随着功能模块的增多，代码量也会迅速膨胀，导致难以维护。 所以，我们希望不同的功能是独立的可拔插的模块。 模块化1234567891011121314151617181920212223242526// 打印 state 中间件function patchStoreToAddLogging(store) &#123; const next = store.dispatch //此处也可以写成匿名函数 store.dispatch = function(action) &#123; let result = next(action) console.log('next state', store.getState()) return result &#125;&#125; // 监控错误中间件function patchStoreToAddCrashReporting(store) &#123; // 这里取到的 dispatch 已经是被上一个中间件包装过的 dispatch，从而实现中间件串联 const next = store.dispatch store.dispatch = function(action) &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('捕获一个异常!', err) throw err &#125; &#125;&#125;patchStoreToAddLogging(store)patchStoreToAddCrashReporting(store) 到这里我们基本实现了可组合、拔插的中间件。 applyMiddleware我们注意到，我们当前写的中间件方法都是先获取 dispatch，然后在方法内替换 dispatch，这部分重复代码我们可以再稍微简化一下。 我们不在方法内替换 dispatch，而是返回一个新的 dispatch，然后让循环来进行每一步的替换： 1234567891011121314151617181920212223242526272829function logger(store) &#123; const next = store.dispatch return function(action) &#123; let result = next(action) console.log('next state', store.getState()) return result &#125;&#125;function crashReporter(store) &#123; const next = store.dispatch return function(action) &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('捕获一个异常!', err) throw err &#125; &#125;&#125;function applyMiddleware(store, middlewares) &#123; middlewares = middlewares.slice() // 返回新数组，避免 reserve() 影响原数组 middlewares.reverse() // 由于循环替换 dispatch 时，前面的中间件在最里层，因此需要翻转数组才能保证中间件的调用顺序 // 循环替换 dispatch middlewares.forEach(middleware =&gt; (store.dispatch = middleware(store)))&#125;applyMiddleware(store, [ logger, crashReporter ]) 纯函数之前的例子已经基本实现我们的需求，但我们还可以进一步改进，上面这个函数看起来仍然不够”纯“，函数在函数体内修改了 store 自身的 dispatch ，产生了所谓的“副作用”，从函数式编程的规范出发，我们可以进行一些改造，借鉴 react-redux 的实现思路，我们可以把 applyMiddleware 作为高阶函数，用于增强 store，而不是替换 dispatch。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; reducer &#125; from './reducer'const logger = store =&gt; next =&gt; action =&gt; &#123; let result = next(action) console.log('next state', store.getState()) return result&#125;const crashReporter = store =&gt; next =&gt; action =&gt; &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('捕获一个异常!', err) throw err &#125;&#125;const thunk = store =&gt; next =&gt; action =&gt; typeof action === 'function' ? action(store.dispatch, store.getState) : next(action)const applyMiddleware = (...middlewares) =&gt; createStore =&gt; reducer =&gt; &#123; const store = createStore(reducer) let &#123; getState, dispatch &#125; = store const params = &#123; getState, // 如果所有中间件都共享同一个 dispatch，出现中间件修改了 dispatch 或者进行异步 dispatch 就可能出错 dispatch: (action) =&gt; dispatch(action) &#125; const middlewareArr = middlewares.map(middleware =&gt; middleware(params)) dispatch = compose(...middlewareArr)(dispatch) return &#123; ...store, dispatch &#125;&#125;// compose 这一步对应了 middlewares.reverse()，是函数式编程一种常见的组合方法// 使传入的中间件函数变成 (...arg) =&gt; mid1(mid2(mid3(...arg)))function compose(...funcs) &#123; if (funcs.length === 0) return arg =&gt; arg if (funcs.length === 1) return funcs[0] return funcs.reduce((a, b) =&gt;(...args) =&gt; a(b(...args)))&#125;export const createStore = (reducer, enhancer) =&gt; &#123; if(applyMiddleware) &#123; return enhancer(createStore)(reducer) &#125; let currentState = &#123;&#125; let observers = [] // 观察者队列 function getState() &#123; return currentState &#125; function dispatch(action) &#123; currentState = reducer(currentState, action) observers.forEach(fn =&gt; fn()) &#125; dispatch(&#123;type:'@STATE_INIT@'&#125;); // 初始化 state 数据 function subscribe(fn) &#123; observers.push(fn) &#125; return &#123; getState, subscribe, dispatch &#125;&#125;createStore(reducer, applyMiddleware(logger, crashReporter, thunk))","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://xyue.me/tags/react/"}]},{"title":"JavaScript 继承的几种方式","date":"2020-04-07T09:15:36.000Z","path":"2020/04/07/javascript-extend/","text":"在了解继承之前，我们先了解构造函数、原型和原型链的相关知识。 构造函数构造函数和普通函数的区别仅在于调用它们的方式不同。只要通过 new 操作符来调用，那它就可以作为构造函数；如果不通过 new 操作符来调用，那么它就是一个普通函数。 实例拥有 constructor 属性，该属性返回创建实例对象的构造函数。 1234567function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person('XYue', 20);console.log(person.constructor === Person); // true 原型我们创建的每个函数都有 prototype 属性，这个属性指向函数的原型对象。原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 在默认情况下，所有原型对象都会自动获得一个 constructor 属性，这个属性包含一个指向 prototype 属性所在函数的指针。 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象（可以通过实例的 __proto__ 来访问构造函数的原型对象）。 123456789101112131415function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;var person1 = new Person('XYue');var person2 = new Person('歆月');person1.sayName(); // XYueperson2.sayName(); // 歆月console.log(person1.__proto__ === Person.prototype); // trueconsole.log(Person.prototype.__proto__ === Object.prototype); // trueconsole.log(Object.prototype.__proto__ === null); // true 原型链每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个可以指向原型对象的内部指针（可以通过 __proto__ 访问）。 假如我们让原型对象等于另一个类型的实例，那么此时原型对象包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，就构成了实例与原型的链条，这就是原型链的基本概念。 继承原型链继承原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1234567891011121314151617function SuperType(name) &#123; this.name = name; this.hobbies = ['唱', '跳', 'rap'];&#125;SuperType.prototype.getHobbies = function() &#123; console.log(this.hobbies);&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;var sub1 = new SubType();var sub2 = new SubType();sub1.hobbies.push('篮球');sub1.getHobbies(); // ['唱', '跳', 'rap', '篮球']sub2.getHobbies(); // ['唱', '跳', 'rap', '篮球'] 缺点 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数 构造函数继承基本思路：在子类型的构造函数中调用超类型构造函数。 123456789101112131415161718function SuperType(name) &#123; this.name = name; this.hobbies = ['唱', '跳', 'rap'];&#125;SuperType.prototype.getHobbies = function() &#123; console.log(this.hobbies);&#125;function SubType(name) &#123; SuperType.call(this, name);&#125;var sub1 = new SubType('XYue-1');var sub2 = new SubType('XYue-2');sub1.hobbies.push('篮球');console.log(sub1.hobbies); // ['唱', '跳', 'rap', '篮球'];console.log(sub2.hobbies); // ['唱', '跳', 'rap'];sub1.getHobbies(); // Uncaught TypeError: sub1.getHobbies is not a function 优点 可以向超类传递参数 解决了原型中包含引用类型值被所有实例共享的问题 缺点 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。 组合继承组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。 基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。 1234567891011121314151617181920212223242526function SuperType(name) &#123; this.name = name; this.hobbies = ['唱', '跳', 'rap'];&#125;SuperType.prototype.getHobbies = function() &#123; console.log(this.hobbies);&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.getAge = function() &#123; console.log(this.age);&#125;var sub1 = new SubType('XYue1', 18);var sub2 = new SubType('XYue2', 20);sub1.hobbies.push('篮球');console.log(sub1.hobbies); // ['唱', '跳', 'rap', '篮球'];console.log(sub2.hobbies); // ['唱', '跳', 'rap'];sub1.getHobbies(); // ['唱', '跳', 'rap', '篮球'];sub1.getAge(); // 18sub2.getAge(); // 20 优点 可以向超类传递参数 每个实例都有自己的属性 实现了函数复用 缺点 无论什么情况下，都会调用两次超类型构造函数。一次是在创建子类型原型的时候，另一次是在子类型构造函数内部 原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 12345function object(obj)&#123; function F()&#123;&#125;; F.prototype = obj; return new F();&#125; 在 object() 函数内部，先添加一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。ECMAScript5 通过新增 Object.create() 方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象（可以覆盖原型对象上的同名属性），在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。 1234567891011var person = &#123; name: 'XYue', hobbies: ['唱', '跳', 'rap']&#125;;var person1 = Object.create(person);var person2 = Object.create(person);person1.hobbies.push('🏀');person2.hobbies.push('⚽️');console.log(person.hobbies); // [\"唱\", \"跳\", \"rap\", \"🏀\", \"⚽️\"]console.log(person1.hobbies); // [\"唱\", \"跳\", \"rap\", \"🏀\", \"⚽️\"]console.log(person2.hobbies); // [\"唱\", \"跳\", \"rap\", \"🏀\", \"⚽️\"] 缺点 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享 寄生式继承寄生继承 是依托于一个对象而生的一种继承方式，因此称之为 寄生。 寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。 1234567891011121314function createObj(obj) &#123; var clone = Object.create(obj); clone.sing = function() &#123; console.log('大山的子孙呦~爱太阳啰~'); &#125; return clone;&#125;var person = &#123; name: 'XYue', hobbies: ['唱', '跳', 'rap']&#125;;var person1 = createObj(person);person1.sing(); // 大山的子孙呦~爱太阳啰~ 缺点 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享 寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链继承的形式来继承方法。 基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 12345678function inheritPrototype(subType, superType) &#123; // 创建超类型原型的一个副本 var prototype = Object.create(superType.prototype); // 为创建的副本添加 constructor 属性 prototype.constructor = subType; // 将新创建的对象赋值给子类型的原型 subType.prototype = prototype;&#125; 至此，我们就可以通过调用 inheritPrototype 为子类型原型赋值： 123456789function SuperType(name) &#123; this.name = name; this.hobbies = ['唱', '跳', 'rap'];&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType); 优点 只调用了一次超类构造函数，效率更高 避免在 SubType.prototype 上面创建不必要的、多余的属性，与其同时，原型链还能保持不变 因此寄生组合继承是引用类型最理性的继承范式。 ES6 继承Class 可以通过 extends 关键字实现继承，如: 12345678910111213141516171819class SuperType &#123; constructor(name) &#123; this.name = name; this.hobbies = ['唱', '跳', 'rap']; &#125; getName() &#123; console.log(this.name); &#125;&#125;class SubType extends SuperType &#123; constructor(name, age) &#123; super(name); this.age = age; &#125;&#125;const sub = new SubType('XYue', 20);sub.getName(); // XYue 使用 extends 关键字实现继承，有一点需要特别说明： 子类必须在 constructor 中调用 super 方法，否则新建实例时会报错。如果没有子类没有定义 constructor 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 super 之后，才能使用 this 关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"}]},{"title":"Promise 实现原理","date":"2020-03-30T10:14:44.000Z","path":"2020/03/30/promise-realize/","text":"什么是 Promise在 javascript 的世界中，代码都是 单线程 执行的。这就导致我们的代码里会有嵌套回调函数，一旦嵌套过多，导致代码不容易理解和维护。为了降低异步编程的复杂性，开发人员一直在寻找各种解决方案，Promise 就是用来处理异步操作的其中一个方案。 下面将根据 Promise/A+ 的规范，来写出符合规范的源码。 Promise 的基本使用12345678const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success'); // 这里如果是 reject('fail')&#125;);promise.then((res)=&gt;&#123; console.log(res); // 输出：success&#125;,(err)=&gt;&#123; console.log(err); // 上面如果执行 reject('fail')，这里就输出 fail&#125;); resolve 找 then 里的成功回调，reject 找 then 里失败的回调。 接下来我们将按自己的方式一步步实现这样的一个 Promise 类，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142const PENDING = \"pending\";const FULFILLED = \"fulfilled\";const REJECTED = \"rejected\";class Promise &#123; constructor(executor) &#123; this.state = PENDING; this.onFulfilled = []; // 成功回调队列 this.onRejected = []; // 失败回调队列 // PromiseA+ 2.1 const resolve = value =&gt; &#123; if (this.state === PENDING) &#123; this.state = FULFILLED; this.value = value; this.onFulfilled.forEach(fn =&gt; fn()); // PromiseA+ 2.2.6.1 &#125; &#125;; const reject = reason =&gt; &#123; if (this.state === PENDING) &#123; this.state = REJECTED; this.reason = reason; this.onRejected.forEach(fn =&gt; fn()); // PromiseA+ 2.2.6.1 &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.state === PENDING) &#123; this.onFulfilled.push(() =&gt; onFulfilled(this.value)); this.onRejected.push(() =&gt; onRejected(this.reason)); &#125; &#125;&#125;module.exports = Promise; 这样我们就简单的实现了一个 Promise 应该拥有的基本功能。 链式调用在上述代码中我们并没有处理 then 的链式调用，直接使用则会报错：TypeError: Cannot read property ‘then’ of undefined。 在 Promise/A+ 规范中提到： 2.2.6 then may be called multiple times on the same promise.2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.2.2.7 then must return a promise [3.3].2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure \\[\\[Resolve]](promise2, x).2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.2.2.7.3 If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.2.2.7.4 If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1. 1234567892.2.6 then 方法可能被多次调用2.2.6.1 如果 promise 变成了 fulfilled 态，所有的 onFulfilled 回调都需要按照 then 的顺序执行2.2.6.2 如果 promise 变成了 rejected 态，所有的 onRejected 回调都需要按照 then 的顺序执行2.2.7 then 必须返回一个 promise2.2.7.1 如果 onFulfilled 或 onRejected 执行的结果为 x，调用 handlePromise2.2.7.2 如果 onFulfilled 或者 onRejected 执行时抛出异常 e，promise2 需要被 reject2.2.7.3 如果 onFulfilled 不是一个函数，promise2 以 promise1 的 value fulfilled2.2.7.4 如果 onRejected 不是一个函数，promise2 以 promise1 的 reason rejected 所以 then 方法里可能返回一个值或者返回的一个 Promise 实例，我们需要分别处理这两种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class Promise &#123; // ... 省略如上 then(onFulfilled, onRejected) &#123; // PromiseA+ 2.2.1 / PromiseA+ 2.2.5 / PromiseA+ 2.2.7.3 / PromiseA+ 2.2.7.4 // 值穿透 promise.then().then().then(res =&gt; &#123; console.log(res); &#125;) onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === \"function\" ? onRejected : reason =&gt; &#123; throw reason; &#125;; // PromiseA+ 2.2.7 返回一个新的 Promise let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.state === FULFILLED) &#123; // PromiseA+ 2.2.2 // PromiseA+ 2.2.4 --- setTimeout 模拟异步任务（规范要求） setTimeout(() =&gt; &#123; try &#123; // PromiseA+ 2.2.7.1 let x = onFulfilled(this.value); handlePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; // PromiseA+ 2.2.7.2 reject(e); &#125; &#125;); &#125; else if (this.state === REJECTED) &#123; // PromiseA+ 2.2.3 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); handlePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125; else if (this.state === PENDING) &#123; this.onFulfilled.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); handlePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); this.onRejected.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); handlePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; &#125;); return promise2; &#125;&#125;function handlePromise(promise2, x, resolve, reject) &#123; // PromiseA+ 2.3.1 promise2 是否等于x，判断是否将自己本身返回，抛出 TypeError 错误 if (promise2 === x) &#123; reject(new TypeError('Chaining cycle')); &#125; // PromiseA+ 2.3.3 if (x &amp;&amp; typeof x === 'object' || typeof x === 'function') &#123; let used; // PromiseA+ 2.3.3.3.3 控制 resolve 或 reject 只执行一次（规范要求） try &#123; // PromiseA+ 2.3.3.1 let then = x.then; // 如果是函数，就认为它是返回新的 promise if (typeof then === 'function') &#123; // PromiseA+ 2.3.3.1 then.call(x, (y) =&gt; &#123; if (used) return; used = true; handlePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; // PromiseA+ 2.3.3.2 if (used) return; used = true; reject(r); &#125;); &#125; else &#123; // PromiseA+ 2.3.3.4 x 是普通值，直接返回 if (used) return; used = true; resolve(x); &#125; &#125; catch (e) &#123; // PromiseA+ 2.3.3.2 if (used) return; used = true; reject(e); &#125; &#125; else &#123; // PromiseA+ 2.3.4 x 是普通值，直接返回 resolve(x); &#125;&#125;module.exports = Promise; 这样我们就实现一个完全符合 Promise/A+ 规范的 Promise 了。 让我们安装测试脚本检测下: 1npm install -g promises-aplus-tests 在 Promise 实现的代码中添加如下代码： 12345678Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125; 对应目录下执行以下命令: 1promises-aplus-tests promise.js promises-aplus-tests 中共有 872 条测试用例，以上代码，可以完美通过所有用例。 整体思路 new Promise 时，需要传递一个 executor 执行器，执行器立刻执行 executor 接受两个参数，分别是 resolve 和 reject promise 只能从 pending 到 rejected, 或者从 pending 到 fulfilled promise 的状态一旦确认，就不会再改变 promise 都有 then 方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled,和 promise 失败的回调 onRejected 如果调用 then 时，promise 已经成功，则执行 onFulfilled，并将 promise 的值作为参数传递进去；如果 promise 已经失败，那么执行 onRejected, 并将 promise 失败的原因作为参数传递进去；如果 promise 的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行（发布订阅） then 的参数 onFulfilled 和 onRejected 可以缺省 promise 可以 then 多次，promise 的 then 方法返回一个 promise 如果 then 返回的是一个结果，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调(onFulfilled) 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调(onRejected) 如果 then 返回的是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功，如果失败，就走下一个 then 的失败 Promise 其他方法虽然我们已经实现了一个 Promise/A+ 规范的 Promise，但是相比原生的 Promise 还缺少一些方法: Promise.prototype.catch() Promise.prototype.finally() Promise.resolve() Promise.reject() Promise.all() Promise.race() 下面，我们将逐一实现： Promise.prototype.catch用于指定出错时的回调，是特殊的 then 方法，catch 之后，可以继续 then。 123Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125; Promise.prototype.finally不管成功还是失败，都会走到 finally 中，并且 finally 之后，还可以继续 then。并且将值原封不动的传递给后面的 then。 1234567891011Promise.prototype.finally = function (callback) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125;);&#125; Promise.resolvePromise.resolve(value) 返回一个以给定值解析后的 promise 对象. 如果 value 是个 thenable 对象，返回的 promise 会跟随这个 thenable 的对象，采用它的最终状态 如果传入的 value 本身就是 promise 对象，那么 Promise.resolve 将不做任何修改、原封不动地返回这个 promise 对象 其他情况，直接返回以该值为成功状态的 promise 对象 123456789101112131415Promise.resolve = function (param) &#123; if (param instanceof Promise) &#123; return param; &#125; return new Promise((resolve, reject) =&gt; &#123; if (param &amp;&amp; param.then &amp;&amp; typeof param.then === 'function') &#123; // 为保持与原生 Promise 对象执行顺序一致，模拟使用 setTimeout setTimeout(() =&gt; &#123; param.then(resolve, reject); &#125;); &#125; else &#123; resolve(param); &#125; &#125;);&#125; Promise.rejectPromise.reject 方法和 Promise.resolve 不同，Promise.reject() 方法的参数会原封不动地作为 reject 的理由，变成后续方法的参数。 12345Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.allPromise.all(promises) 返回一个 promise 对象。 如果传入的参数是一个空的可迭代对象，那么此 promise 对象回调完成 resolve，只有此情况，是同步执行的，其它都是异步返回的 如果传入的参数不包含任何 promise，则返回一个异步完成 等待 promises 中所有的 promise 执行完毕 如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败 在任何情况下，Promise.all 返回的 promise 完成状态的结果都是一个数组 12345678910111213141516171819202122232425Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; //promises[i] 可能是普通值 Promise.resolve(promises[i]).then((data) =&gt; &#123; processValue(i, data); &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125; &#125; &#125;);&#125; Promise.allSettled不同于 Promise.all，一旦有一个 promise 执行失败，就无法获得其他成功 promise 返回。Promise.allSettled 方法下无论某个 promise 成功与否，所有的 promise 总是被 resolve 的，并且值是所有 promise 执行结果的描述。 123456789101112131415161718192021222324Promise.allSettled = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; //promises[i] 可能是普通值 Promise.resolve(promises[i]).then((data) =&gt; &#123; processValue(i, &#123; status: 'fulfilled', value: data &#125;); &#125;, (err) =&gt; &#123; processValue(i, &#123; status: 'rejected', reason: err &#125;) &#125;); &#125; &#125; &#125;);&#125; Promise.race顾名思义，Promse.race 就是赛跑的意思。意思就是说，Promise.race([p1, p2, p3]) 里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 如果传的参数数组是空，则返回的 promise 将永远等待 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值 1234567891011121314151617Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; if (promises.length === 0) &#123; return; &#125; else &#123; for (let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then((data) =&gt; &#123; resolve(data); return; &#125;, (err) =&gt; &#123; reject(err); return; &#125;); &#125; &#125; &#125;);&#125; 详细代码，同步 github","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://xyue.me/tags/promise/"}]},{"title":"从多线程到 Event Loop","date":"2020-03-21T05:45:07.000Z","path":"2020/03/21/event-loop/","text":"在我们的认知中，javascript 是单线程的，但它又是如何完成诸如异步请求这种多线程操作的呢？我们先从进程、线程的角度来了解这个问题。 进程与线程 进程 是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程 是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 不同进程之间也可以通信，代价较大 简单理解，我们把 cpu 比作工厂，工厂有多个车间，但工厂的电力有限，每次只能供给一个车间使用（单个 cpu 一次只能运行一个任务）。进程 就好比工厂的车间，它代表 cpu 所能处理的单个任务, 进程之间相互独立，任一时刻，cpu 总是运行一个进程，其他进程处于非运行状态。 cpu 使用时间片轮转进度算法来实现同时运行多个进程。线程 就好比车间里的工人，一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。 一个 进程 可以包括多个 线程，多个 线程 共享 进程 资源。 浏览器包含了哪些进程 主进程 协调控制其他子进程（创建、销毁） 浏览器界面显示，用户交互，前进、后退、收藏 将渲染进程得到的内存中的 Bitmap，绘制到用户界面上 处理不可见操作，网络请求，文件访问等 第三方插件进程 每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程 用于3D绘制等 渲染进程，就是我们说的浏览器内核 负责页面渲染，脚本执行，事件处理等 每个tab页一个渲染进程 了解到浏览器所包含的进程，我们可以发现，渲染进程是前端操作最重要的一环。 渲染进程我们知道，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。 对于 渲染进程 而言，它也是多线程的，包含： GUI 渲染线程 负责渲染页面，布局和绘制 页面需要重绘和回流时，该线程就会执行 与 JS 引擎线程互斥，防止渲染结果不可预期 JS 引擎线程 负责处理解析和执行 javascript 脚本程序 只有一个 JS 引擎线程（单线程） 与 GUI 渲染线程互斥，防止渲染结果不可预期 事件触发线程 用来控制事件循环（鼠标点击、setTimeout、ajax 等） 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中 定时触发器线程 setInterval 与 setTimeout 所在的线程 定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的 计时完毕后，通知事件触发线程 异步 http 请求线程 浏览器有一个单独的线程用于处理 ajax 请求 当请求完成时，若有回调函数，通知事件触发线程 当我们了解了渲染进程包含的线程后，我们思考为什么 javascript 是单线程的。 为什么是单线程因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。 从 event loop 看 JS 运行机制到了这里，终于要进入我们的主题，什么是 event loop。 先理解一些概念： JS 分为同步任务和异步任务 同步任务都在 JS 引擎线程上执行，形成一个执行栈 事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放到任务队列中 执行栈中所有同步任务执行完毕，此时 JS 引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行 在前端开发中我们会通过 setTimeout、setInterval 来指定定时任务，通过 xhr、fetch 发送网络请求。 我们知道，不管是这些定时任务或者网络请求，这些代码在执行，本身是同步任务的，而其中的回调函数才是异步任务。 当代码执行到 setTimeout、setInterval 时，实际上是 JS引擎线程 通知 定时触发器线程，在间隔指定时间后，会触发一个回调事件， 而 定时触发器线程 在接收到这个消息后，会在等待的时间后，将回调事件放入到由 事件触发线程 所管理的事件队列中。 当代码执行到 xhr、fetch 时，实际上是 JS引擎线程 通知 异步http请求线程，发送一个网络请求，并制定请求完成后的回调事件， 而 异步http请求线程 在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程 所管理的事件队列中。 当我们的同步任务执行完，JS引擎线程 会询问 事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给 JS引擎线程 执行。 用一张图来解释： 总结： JS 引擎线程执行执行栈中的事件 执行栈中的事件执行完毕，就开始读取事件队列中的事件 事件队列中的回调事件加入到执行栈依次执行 2,3 重复循环 宏任务、微任务当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中 宏任务、微任务。 宏任务我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），每一个宏任务会从头到尾执行完毕，不会执行其他。我们前文提到过 JS引擎线程 和 GUI渲染线程 是互斥的关系，浏览器为了能够使宏任务和 DOM 任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI 渲染线程 开始工作，对页面进行渲染。 1// 宏任务--&gt;渲染--&gt;宏任务--&gt;渲染--&gt;．．． script（主代码块），setTimeout，setInterval、I/O(ajax),setImmedidate(node)，都属于宏任务。 举个例子🌰： 1234document.body.style = 'background:black';document.body.style = 'background:red';document.body.style = 'background:blue';document.body.style = 'background:grey'; 我们将这段代码放到浏览器控制台执行一下，看一下效果： 我们看到，页面背景会在瞬间变成灰色。这是因为以上代码属于同一次宏任务，所以全部执行完才触发页面渲染，渲染时GUI 渲染线程会将所有 UI 改动合并优化，所以在视觉效果上，只会看到页面变成灰色。 再来个例子🌰🌰： 1234document.body.style = 'background:blue';setTimeout(function() &#123; document.body.style = 'background:black'&#125;, 0); 执行一下，看下效果： 我们看到，页面先显示成蓝色背景，然后又变成了黑色背景，这是因为以上代码属于两次 宏任务，第一次 宏任务 执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次 宏任务 将背景变成黑色。 微任务我们已经知道 宏任务 结束后，会执行渲染，然后执行下一个 宏任务， 而 微任务 可以理解成在当前 宏任务 执行后立即执行的任务。 也就是说，当 宏任务 执行完，会在渲染前，将执行期间所产生的所有 微任务 都执行完。 1// 宏任务--&gt;微任务--&gt;渲染--&gt;宏任务--&gt;微任务--&gt;渲染--&gt;．．． process.nextTick(node)，Promise，MutationObserver 属于微任务。 process.nextTick 是有一个插队操作的，就是说他进入微任务队列时，会插到除了 process.nextTick 其他的微任务前面。 举个例子🌰： 1234567document.body.style = 'background:blue'console.log(1);Promise.resolve().then(()=&gt;&#123; console.log(2); document.body.style = 'background:black'&#125;);console.log(3); 执行一下，看下效果： 控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务，在微任务中将背景变成了黑色，然后才执行的渲染。 再比如说： 12345678setTimeout(() =&gt; &#123; console.log(1); Promise.resolve(3).then(data =&gt; console.log(data));&#125;, 0);setTimeout(() =&gt; &#123; console.log(2)&#125;, 0);// 1 3 2 上面代码共包含两个 setTimeout，也就是说除主代码块外，还有两个 宏任务，其中第一个 宏任务 执行中，输出 1，并且创建了 微任务队列，所以在下一个 宏任务队列 执行前，先执行 微任务，在 微任务 执行中，输出 3 ，微任务 执行后，执行下一次 宏任务，执行中输出 2。 总结 执行一个宏任务 （栈中没有就从 事件队列 中获取） 执行过程中如果遇到 微任务，就将它添加到 微任务队列中 宏任务执行完毕后，立即执行当前 微任务队列 中的所有 微任务 （依次执行） 当前 宏任务 执行完毕，开始检查渲染，然后 GUI 渲染线程 接管渲染 渲染完毕后，JS引擎线程 继续接管，开始下一个 宏任务（从事件队列中获取） 题外话123setTimeout(()=&gt;console.log(3), 2);setTimeout(()=&gt;console.log(2), 1);setTimeout(()=&gt;console.log(1), 0); 没有深入接触过 timer 的同学如果直接从代码中的延时设置来看，会回答：1、2、3。 而另一些有一定经验的同学可能会回答：3、2、1。因为 MDN 的 setTimeout 文档中提到 HTML 规范最低延时为 4ms： (补充说明：最低延时的设置是为了给CPU留下休息时间） In fact, 4ms is specified by the HTML5 spec and is consistent across browsers released in 2010 and onward. Prior to (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2), the minimum timeout value for nested timeouts was 10 ms. 而真正痛过的同学会告诉你，答案是：1、0、2。 我们发现 0ms 和 1ms 的延时效果是一样的，通过资料我们发现： 在 chrome 中12// https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp#93double intervalMilliseconds = std::max(oneMillisecond, interval * oneMillisecond); 这里 interval 就是传入的数值，可以看出传入 0 和传入 1 结果都是 oneMillisecond，即 1ms。 这样解释了为何 1ms 和 0ms 行为是一致的，那 4ms 到底是怎么回事？查阅 HTML 规范，发现虽然有 4ms 的限制，但是是存在条件的，详见规范第 11 点： If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4. 在 node 中123// https://github.com/nodejs/node/blob/v8.9.4/lib/timers.js#L456if (!(after &gt;= 1 &amp;&amp; after &lt;= TIMEOUT_MAX)) after = 1; // schedule on next tick, follows browser behavior 代码中的注释直接说明了，设置最低 1ms 的行为是为了向浏览器行为看齐。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"}]},{"title":"this、call、apply、bind","date":"2020-03-18T07:16:37.000Z","path":"2020/03/18/this-call-apply-bind/","text":"this面向对象语言中 this 表示当前对象的一个引用。但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 普通函数指向函数的调用者默认绑定12345var a = 'xyue';function foo() &#123; console.log(this.a);&#125;foo(); // xyue foo() 直接调用，非严格模式下 this 指向 window ，严格模式下 this 指向 undefined; 隐式绑定12345678910var a = 'xyue1';var obj = &#123; a: 'xyue2', foo() &#123; console.log(this.a); &#125;&#125;obj.foo(); // xyue2var bar = obj.foo; bar(); // xyue1 obj.foo() 是 obj 通过 . 运算符调用了 foo()，所以 this 指向 obj；bar() 实际上是把 foo 函数赋值给了 bar，没有调用者，所以使用的是默认绑定规则，这里的 this 指向 window。 显式绑定12345678910var a = 'xyue1';var obj = &#123; a: 'xyue2', foo() &#123; console.log(this.a); &#125;&#125;var bar = obj.foo; bar(); // xyue1bar.call(obj) // xyue2 使用 call、 apply 、 bind 可以显式修改 this 的指向。 new 绑定12345function Foo(name) &#123; this.name = name;&#125;var foo = new Foo('xyue');foo.name; // xyue new 实现原理 箭头函数指向函数所在的所用域箭头函数中没有 this 绑定，在箭头函数中 this 始终指向函数所在的所用域。（箭头函数不能作为构造函数） 1234567891011const obj = &#123; name: 'xyue', getName1() &#123; console.log(this.name); &#125;, getName2: () =&gt; &#123; console.log(this.name); &#125;&#125;obj.getName1(); // xyueobj.getName2(); // undefined call、apply、bind 实现在 javascript 中，call、apply、bind 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 相同点 均可以改变 this 指向，第一个参数为 this的指向对象 不同点 函数调用 call、apply 时，直接调用函数，而 bind 返回一个新的函数 call、bind 接收序列参数，apply 接收参数数组 call举个例子 1234567var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 那么我们该怎么实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 1234567var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 这个时候 this 就指向了 foo。 所以我们实现的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 12345678910111213141516Function.prototype.myCall = function(context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(arguments[i]); &#125; var result; if(args.length &gt; 0)&#123; result = eval('context.fn(' + args +')'); &#125;else &#123; result = context.fn(); &#125; delete context.fn; return result;&#125; 或者使用 ES6 扩展运算符，解构赋值 12345678Function.prototype.myCall = function() &#123; var [context, ...args] = arguments; var context = context || window; context.fn = this; var result = context.fn(...args); delete context.fn; return result;&#125; applyapply 的实现跟 call 类似，差异在与参数的传递上： 123456789Function.prototype.myApply = function() &#123; // args 第二个参数为数组 var [context, args] = arguments; var context = context || window; context.fn = this; var result = context.fn(...args); delete context.fn; return result;&#125; bind bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 可以看出 bind 的 2 个特点： 返回一个函数 可以传入参数 12345678Function.prototype.myBind = function(context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); return function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;&#125; 但这样还存在一个问题，如下 1234567891011121314151617181920212223242526var foo = &#123; value: 1&#125;;function Bar(name,age) &#123; this.hobby = 'sing'; console.log(this.value); console.log(name); console.log(age);&#125;Bar.prototype.friend = 'xyue';var bindFoo1 = Bar.bind(foo, 'fuzy');var obj1 = new bindFoo1('18');// undefined// fuzy// 18console.log(obj1.hobby); // singconsole.log(obj1.friend); // xyuevar bindFoo2 = Bar.myBind(foo, 'fuzy');var obj2 = new bindFoo2('18');// 1// fuzy// 18console.log(obj2.hobby); // undefinedconsole.log(obj2.friend); // undefined 一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 我们看到，当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。 所以我们可以通过修改返回的函数的原型来实现： 12345678910Function.prototype.myBind = function(context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125;; fBound.prototype = this.prototype; return fBound;&#125; 但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 123456789101112Function.prototype.myBind = function(context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 说到这，顺便说一下 Object.create，该方法创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__。不考虑第二个参数，对其主要功能做简单实现： 12345Object.create = function(obj) &#123; function f() &#123;&#125;; f.prototype = obj; return new f;&#125;; 可以看到我们可以发现，这不就是创建一个空函数进行中转么，所以我们的实现代码如下： 12345678910Function.prototype.myBind = function(context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125;; fBound.prototype = Object.create(this.prototype); return fBound;&#125; 当然这都是模拟实现，并不是完美的，比如： 123456789101112131415var foo = &#123; value: 1&#125;;function Bar(name,age) &#123; this.hobby = 'sing'; console.log(this.value); console.log(name); console.log(age);&#125;Bar.prototype.friend = 'xyue';var bindFoo1 = Bar.bind(foo, 'fuzy');var bindFoo2 = Bar.myBind(foo, 'fuzy');console.log(bindFoo1.prototype); // undefinedconsole.log(bindFoo2.prototype); // Bar &#123;&#125; 我们看到原生的 bind 返回的函数是没有 prototype 属性的。正如原生的 bind 方法的特性定义的那样。 bind方法所返回的函数并不包含 prototype 属性，并且将这些绑定的函数用作构造函数所创建的对象从原始的未绑定的构造函数中继承 prototype 所以我们用 es6 方法实现做一些补充： 123456789101112Function.prototype.myBind = function(context, ...args) &#123; var self = this; var Fn = function(...bindArgs) &#123; var allArgs = args.concat(bindArgs); if(this instanceof Fn) &#123; return new self(...allArgs); &#125; return self.apply(context, allArgs); &#125; delete Fn.prototype; return Fn;&#125; 这样与原生的 bind 表现就大致一样了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"}]},{"title":"javascript new 原理","date":"2020-03-17T10:12:26.000Z","path":"2020/03/17/what-did-new-do/","text":"new 的作用我们先通过简单的例子来了解下 new 的作用吧。 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype.getName = function () &#123; console.log(this.name);&#125;var person = new Person('xyue');console.log(person); // Person &#123;name: \"xyue\"&#125;console.log(person.name); // xyueconsole.log(person.getName()); // xyue 从上边例子中我们可以得到结论： 通过 new 构造函数 Person 创建出来的实例可以访问到构造函数中的属性 通过 new 构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性，也就是说通过 new 操作符，实例与构造函数通过原型链连接了起来 但是当前的构造函数 Person 并没有 return 任何值，如果我们让它返回值会发生什么事情呢？ 1234567function Person(name) &#123; this.name = name; return 1;&#125;var person = new Person('xyue');console.log(person); // Person &#123;name: \"xyue\"&#125;console.log(person.name); // xyue 虽然在构造函数中返回了 1，但是这个返回值（原始值）并没有任何用处，得到的结果完全一样。所以通过这个例子，我们可以得出另外一个结论： 构造函数如果返回原始值，那么这个返回值没有意义 试完了返回原始值，我们再来试试返回对象会发生什么事情吧： 12345678function Person(name) &#123; this.name = name; console.log(this); // Person &#123;name: \"xyue\"&#125; return &#123; age: 18 &#125;;&#125;var person = new Person('xyue');console.log(person); // &#123;age: 18&#125;console.log(person.name); // undefined 通过这个例子我们可以发现，当构造函数返回值为对象时，内部的 this 虽然正常工作，但是这个返回值会被正常的返回出去。通过这个例子，我们再次得到一个结论： 构造函数如果返回值为对象，那么这个返回值会被正常使用 实现通过以上几个例子，我们大致了解了 new 操作符的几个作用。 new 运算符 创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即{}） 链接该对象（即设置该对象的构造函数）到另一个对象 将步骤 1 新创建的对象作为 this 的上下文 如果该函数没有返回对象，则返回 this 1234567891011121314function _new() &#123; // 创建的新对象 var obj = &#123;&#125;; // 第一个参数是构造函数 var [constructor, ...args] = [...arguments]; // 将新对象的的原型指向当前构造函数的原型 obj.__proto__ = constructor.prototype; // 执行构造函数，将属性或方法添加到创建的空对象上 var result = constructor.apply(obj, args); // 如果没有返回其他对象，就返回 obj，否则返回其他对象 return typeof result === 'object' ? result : obj;&#125;_new(Person,'xyue'); // Person &#123;name: \"xyue\"&#125; 通过 new 操作符，我们可以创建原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法，所以 new 存在的意义在于它实现了 javascript 中的继承，而不仅仅是实例化了一个对象。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"}]},{"title":"CSS 代码书写规范","date":"2018-08-28T03:43:43.000Z","path":"2018/08/28/css-code-writing-standard/","text":"文件在样式文件的第一行首个字符位置写上 @charset 规则，编码名用 “UTF-8”。 123@charset \"UTF-8\";.xyue&#123;&#125; 格式化样式书写一般有两种： 展开格式 (Expanded) 1234.xyue &#123; display: block; width: 100px;&#125; 紧凑格式 (Compact) 1.xyue &#123;display: block;width: 100px;&#125; 使用展开格式书写样式 大小写样式选择器，属性名，属性值关键字均使用小写字母书写，属性字符串允许使用大小写。 123456789/* YES */ .xyue &#123; font-family: 'Microsoft YaHei UI';&#125;/* NO */.XYUE &#123; DISPLAY: BLOCK;&#125; 选择器 尽量少用通用选择器 * 不使用 ID 选择器 不使用无具体语义定义的标签选择器 123456789/* YES */.xyue &#123;&#125;.xyue li &#123;&#125;.xyue li p&#123;&#125;/* NO */*&#123;&#125;#xyue &#123;&#125;.xyue div&#123;&#125; 代码易读性每个属性声明末尾都要加分号123456789/* YES */.xyue &#123; width: 100%; &#125;/* NO */.xyue&#123; width: 100%&#125; 左括号与类名之间一个空格，冒号与属性值之间一个空格123456789/* YES */.xyue &#123; width: 100%; &#125;/* NO */.xyue&#123; width:100%;&#125; 逗号分隔的取值，逗号之后一个空格123456789/* YES */.xyue &#123; box-shadow: 1px 1px 1px #000, 2px 2px 2px #999;&#125;/* NO */.xyue &#123; box-shadow: 1px 1px 1px #000,2px 2px 2px #999;&#125; 为单个css选择器或新申明开启新行12345678910111213141516/* YES */.xyue, .xyue_logo, .xyue_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125;/* NO */.xyue,.xyue_logo,.xyue_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0123456789/* YES */.xyue &#123; color: rgba(255,255,255,.5);&#125;/* NO */.xyue &#123; color: rgba( 255, 255, 255, 0.5 );&#125; 属性值十六进制数值能用简写的尽量用简写123456789/* YES */.xyue &#123; color: #fff;&#125;/* NO */.xyue &#123; color: #ffffff;&#125; 不要为 0 指明单位123456789/* YES */.xyue &#123; margin: 0 10px;&#125;/* NO */.xyue &#123; margin: 0px 10px;&#125; 属性值引号123456789/* YES */.xyue &#123; font-family: 'Microsoft YaHei UI';&#125;/* NO */.xyue &#123; font-family: \"Microsoft YaHei UI\";&#125; 属性书写顺序遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.xyue &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;&#125; CSS3 浏览器私有前缀在前，标准前缀在后","tags":[{"name":"css","slug":"css","permalink":"http://xyue.me/tags/css/"}]},{"title":"JS 易混淆的方法整理","date":"2018-02-23T06:12:58.000Z","path":"2018/02/23/js-easy-to-confuse-methods/","text":"js的字符串方法如substr、substring，数组方法如slice、splice等名字相近，用法稍有不同，让开发者在开发过程中总是记不起其用法，需要查资料。现整理一下，希望有助大家记忆。 String 对象slice stringObject.slice(start, end) 123456var a = 'Hello world!';var b = a.slice(2);var c = a.slice(-4, -2);// a: 'Hello world!'// b: 'llo world!'// c: 'rl'，参数可为负 substr stringObject.substr(start, length) 123456var a = 'Hello world!';var b = a.substr(0, 4);var c = a.substr(-5, 2);// a: 'Hello world!'// b: 'Hell'// c: 'or'，参数可为负 substring stringObject.substring(start, stop) 12345678var a = 'Hello world!';var b = a.substring(0, 4);var c = a.substring(3, 2);var d = a.substring(0, -1);// a: 'Hello world!'// b: 'Hell'// c: 'l'，start比stop小，交换这两个参数// d: ''，参数为负，返回空字符串 slice、substr、substring都是字符串的切割方法，三者之间有细微的区别，根据不同的使用场景可以灵活使用。三种方法都是生成新的字符串，而不是修改原string。 Array对象concat arrayObject.concat(arrayX, arrayX, …, arrayX) 参数可以为具体的值，也可以为数组对象，可以任意多个。不改变现有的数组，返回被连接数组的一个副本。 123456var a = [1, 2, 3];var b = a.concat(4, 5);var c = a.concat([4, 5]);// a: [1, 2, 3]// b: [1, 2, 3, 4, 5]// c: [1, 2, 3, 4, 5] pop arrayObject.pop() 删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。该方法会改变原数组。 1234var a = [1, 2, 3];var b = a.pop();// a: [1, 2]，修改了原数组// b: 3，返回删除元素的值 push arrayObject.push(newelement1,newelement2,…,newelementX)\\ 参数顺序添加到 arrayObject 的尾部，直接修改 arrayObject。 1234var a = [1, 2, 3];var b = a.push(4, 5);// a: [1, 2, 3, 4, 5]，修改了原数组// b: 5，返回修改后的数组的长度 shift arrayObject.shift() 把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。该方法会改变原数组。类比pop方法。 1234var a = [1, 2, 3];var b = a.shift();// a: [2, 3]，修改了原数组// b: 1，返回删除元素的值 unshift arrayObject.unshift(newelement1, newelement2, …., newelementX) 向数组的开头添加一个或更多元素，并返回新的长度。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 1234var a = [1, 2, 3];var b = a.unshift(4, 5);// a: [ 4, 5, 1, 2, 3 ]，修改了原数组// b: 5，返回修改后的数组的长度 slice arrayObject.slice(start, end) 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。该方法不会修改原数组。 123456789var a = [1, 2, 3, 4, 5];var b = a.slice(2);// a: [1, 2, 3, 4, 5]，不修改原数组// b: [3, 4, 5]，返回新数组var c = [1, 2, 3, 4, 5];var d = c.slice(2, -1);// c: [1, 2, 3, 4, 5]，不修改原数组// d: [3, 4]，返回新数组 splice arrayObject.splice(index, howmany, item1, …, itemX) 可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。 12345678910111213141516171819var a = [1, 2, 3, 4, 5];var b = a.splice(1, 1);// a: [1, 3, 4, 5]，修改了原数组// b: [2]，返回新数组var c = [1, 2, 3, 4, 5];var d = c.splice(-1, 1);// c: [1, 2, 3, 4]，修改了原数组// d: [5]，返回新数组var e = [1, 2, 3, 4, 5];var f = e.splice(1, 1, 6, 7);// e: [ 1, 6, 7, 3, 4, 5 ]，修改了原数组// f: [2]，返回新数组var g = [1, 2, 3, 4, 5];var h = g.splice(1, 0, 8);// g: [ 1, 8, 2, 3, 4, 5 ]，修改了原数组// h: []，没有删除值，返回空数组 sort arrayObject.sort(sortBy) 无参数时，将按字母顺序对数组中的元素进行排序。参数为比较函数时，如果要交换 prev 和 next 的值，返回大于 0 的值。 123456var a = [1, 10, 8, 6, 9];var b = a.sort(function (prev, next) &#123; return prev - next;&#125;);// a: [1, 6, 8, 9, 10]，修改了原数组// b: [1, 6, 8, 9, 10]，返回修改后的数组 reverse arrayObject.reverse() 用于颠倒数组中元素的顺序。会改变原数组。 1234var a = [1, 2, 3];var b = a.reverse();// a: [3, 2, 1]，修改了原数组// b: [3, 2, 1]，返回修改后的数组 map arrayObject.map(function(currentValue, index, arrayObject) {}) 对数组的每一项进行处理，返回新数组。 1234var a = [1, 2, 3];var b = a.map((curVal) =&gt; curVal * 2);// a: [1, 2, 3]，不修改原数组// b: [2, 4, 6]，返回新数组 forEach arrayObject.forEach(function(currentValue, index, arrayObject) {}) 数组的每个元素执行一次提供的函数。一般来说不修改原数组，但也可以通过处理函数修改原数组。该方法很灵活，可类比for...of。 123456var a = [1, 2, 3];var sum = 0;var b = a.forEach((curVal) =&gt; sum += curVal);// a: [1, 2, 3]，不修改原数组// b: undefined，forEach不返回值// sum: 6 find arrayObject.find(function(currentValue, index, arrayObject) {}) 返回数组中第一个满足测试条件（返回 true ）的元素。如果不存在这样的元素，返回undefined。findIndex类似，只不过返回的是第一个满足测试条件的元素的index。 123456var a = [1, 2, 3];var b = a.find((curVal) =&gt; curVal === 1);var c = a.find((curVal) =&gt; curVal === 4);// a: [1, 2, 3]，不修改原数组// b: 1// c: undefined filter arrayObject.filter(function(currentValue, index, arrayObject) {}) 返回数组中所有满足测试条件（返回 true ）的元素组成的数组。如果不存在这样的元素，返回[]。 123456var a = [1, 2, 3];var b = a.filter((curVal) =&gt; curVal &gt; 1);var c = a.filter((curVal) =&gt; curVal &gt; 3);// a: [1, 2, 3]，不修改原数组// b: [2, 3]// c: [] reduce arrayObject.filter(function(previousValue, currentValue, currentIndex, arrayObject) {}, initialValue) 接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。 如果没有 initialValue 参数, reduce 从 index 为 1 开始执行回调函数,跳过第一个 index。如果有 initialValue 参数, reduce 将从 index 为 0 开始执行回调。如果数组是空的并且没有 initialValue 参数,将会抛出 TypeError 错误。如果数组只有一个元素并且没有初始值 initialValue ,或者有 initialValue 但数组是空的, 这个唯一的值直接被返回而不会调用回调函数。 1234var a = [1, 2, 3];var b = a.reduce((prevResult, curItem) =&gt; prevResult + curItem);// a: [1, 2, 3]，不修改原数组// b: 6 除了 Array 的pop、push、shift、unshift、splice、sort、reverse 这 7 个方法会修改原数组，其他方法均不会修改原数组。 查看原文","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"备忘","slug":"备忘","permalink":"http://xyue.me/tags/备忘/"}]},{"title":"Git 备忘录","date":"2018-02-22T01:03:55.000Z","path":"2018/02/22/git-memo/","text":"Git 的一些常用操作备忘。 配置安装好 Git 之后，配置你的资料: 1234# 配置用户名git config --global user.name# 配置邮箱地址git config --global user.email 生成 SSH 密钥1ssh-keygen -C 'your@email.address' -t rsa 初始化项目1234567# 初始化 git 项目git init# 添加一个叫 origin 的源# 使用 ssh 地址git remote add origin git@github.com:username/reponame.git# 使用 username/password 登录 https 地址git remote add origin https://username@password:github.com/username/reponame.git 推送到服务器123456# 记录所有新增和删除的文件git add -A# 提交git commit -m \"message\"# 推送到服务器端git push origin master 更新到本地12# 源 + 分支名git pull origin master 克隆项目1234# 克隆到以这个项目名命名的文件夹git clone https://github.com/username/reponame.git# 克隆到你自定义的文件夹git clone https://github.com/username/reponame.git name gh-pages12# 将 dist 目录推送到 gh-pages 分支git subtree push --prefix dist origin gh-pages To be continued…","tags":[{"name":"git","slug":"git","permalink":"http://xyue.me/tags/git/"},{"name":"备忘","slug":"备忘","permalink":"http://xyue.me/tags/备忘/"}]},{"title":"Material Design 涟漪效果","date":"2018-01-26T07:39:35.000Z","path":"2018/01/26/material-design-ripple-effect/","text":"设计思路结构分析 Material Design 的 Button Ripple Effect 不难发现，涟漪的扩散是在 Button 的内部进行的，所以我们需要在触发的时候向其内部加入span（自定义）。 扩散半径span是以圆向四周扩散，为完全扩散到button边缘，span的直径应是button宽高最长那一边的 2 倍。 扩散中心点扩散是以鼠标点击为中心，所以我们需要获取到鼠标点击相对button的位置，但这还不够，因为扩散是从中心开始的，所以还要减去span的半径长度，如下图： left = clentX - button.left - 直径 / 2 top = clentX - button.top - 直径 / 2 示例 实际应该在button内部扩充一个span填满整个button，再赋予这个span添加涟漪的点击效果，这样button就不会因为必须添加 position: relative;overflow: hidden; 而影响布局了，小伙伴赶快去试试吧！😉 参考Material Design 水波纹点按效果","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"css","slug":"css","permalink":"http://xyue.me/tags/css/"},{"name":"html","slug":"html","permalink":"http://xyue.me/tags/html/"}]},{"title":"CSS 黑魔法小技巧 [ing...]","date":"2017-12-15T09:09:01.000Z","path":"2017/12/15/css-magic-skill/","text":"利用 content 属性 attr 抓取资料 鼠标悬浮提示文字，类似 github 的这种，如图： 相信大家第一想到的就是伪元素——after、before，利用 content 来显示不同的提示文字，但不同元素提示文字不一定相同。在不能使用 javascript 的前提条件下，我们该如何去控制 content 的内容呢？ 利用 content 属性attr抓取资料。在 attr 里面写入 html 中属性名称，这样伪元素 (:after) 就能获取到该属性的值。 1&lt;div data-msg=\"Open this file in Github Desktop\"&gt;hover&lt;/div&gt; 123456789101112131415161718div&#123; width:50px; position:relative; cursor: pointer; &#125;div:hover:after&#123; content:attr(data-msg); position:absolute; left:0; top:25px; width:400%; text-align:center; font-size: 12px; line-height:30px; color: #fff; background: #1b1f23; border-radius: 3px;&#125; 效果，如图： 除此之外，你还可以结合其他选择器使用，例如：使用属性选择器选择空链接 显示没有文本值但是href属性具有链接的a元素的链接： 123a[href^=\"http\"]:empty::before &#123; content: attr(href);&#125; tab 切换实现 Tab 切换的难点在于如何使用 CSS 接收到用户的点击事情并对相关的节点进行操作。即： 如何接收点击事件 如何操作相关DOM 这里我们采用:target伪类接收点击事件。 URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。:target选择器可用于选取当前活动的目标元素。 在 :target 触发的时候分别去操作相关 DOM。 123456&lt;ul class=\"nav\"&gt; &lt;li&gt;&lt;a href=\"#tab1\"&gt;tab1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#tab2\"&gt;tab2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=\"tab1\"&gt;111111111111&lt;/div&gt;&lt;div id=\"tab2\"&gt;222222222222&lt;/div&gt; 123456#tab1,#tab2&#123; display: none;&#125;#tab1:target,#tab2:target&#123; display: block;&#125; 至此，两个问题都已经解决，剩下的就是一些样式的修补工作。 自定义文字下划线使用linear-gradient定义下划线 12&lt;span class=\"wave\"&gt;南月凡歆&lt;/span&gt;&lt;span class=\"dashed\"&gt;南月凡歆&lt;/span&gt; 1234567891011121314151617181920212223242526span&#123; position: relative; display: inline-block;&#125;span:after&#123; content: ''; display: block; position: absolute; top: 110%; width: 100%; height: 3px;&#125;/** * 波浪线，渐变构造'X'，截取上半部分，得到一个'V',从而结合 repeat 形成波浪线 */span.wave:after &#123; background: linear-gradient(135deg, transparent, transparent 45%, red, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, red, transparent 55%, transparent 100%); background-size: 6px 6px;&#125;span.dashed:after &#123; background: linear-gradient(90deg,#03A9F4 50%,transparent 0); background-size: 6px 6px;&#125; 利用 pointer-events 禁用事件效果pointer-events：字面理解是鼠标事件。 当使用 pointer-events:none 时，表示它将捕获不到任何事件，而只是让事件穿透到它的下面。 场景：在做tab切换的时候，当选中当前项，禁用当前标签的事件，只有切换其他tab的时候，才重新请求新的数据。 1234567891011&lt;ul&gt; &lt;li&gt; &lt;a class=\"tab active\" href=\"https://google.com\"&gt;google&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a class=\"tab\" href=\"https://facebook.com\"&gt;facebook&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a class=\"tab\" href=\"https://stackoverflow.com\"&gt;stackoverflow&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 123.active&#123; pointer-events: none;&#125; 适合 pointer-events 的场景有很多。禁用事件；作为覆盖物不影响下层操作，遇到这类情况都可以考虑喲。 rem 布局移动端用 rem 布局时候，根据不同的屏幕宽度要设置不同的 font-size 来做到适配。 例如：以750px设计稿作为基准，根节点设置 font-size 为 100px，只考虑 DPR 为 2 的最简情况。 1document.querySelector('html').style.fontSize = `$&#123;window.innerWidth / 7.5 &#125;px`; 等同与 123html&#123;font-size: calc(100vw / 7.5)&#125; 三角形在不使用图片的情况，实现一个简单的三角形箭头 1&lt;div id=\"triangle-top\"&gt;&lt;/div&gt; 1234567#triangle-top &#123; width: 0; height: 0; border-left: 30px solid transparent; border-right: 30px solid transparent; border-bottom: 60px solid red;&#125; 文本溢出省略有时我们会遇到这样的需求，将一段文字单行，或者多行显示，超出的部分用省略号代替。相信很多同学都曾用 javascript 截取字符串拼接省略号以达到这样的效果，但由于每个字实际表现宽度的不一致，往往需要去单独的控制截取长度。 但其实，用 css 就能完美的解决。 1&lt;div&gt;借一盏午夜街头 昏黄灯光 照亮那坎坷路上人影一双 借一寸三九天里 冽冽暖阳 融这茫茫人间刺骨凉&lt;/div&gt; 单行文本123456div&#123; width: 300px; overflow : hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文本12345678div&#123; width: 300px; overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://xyue.me/tags/css/"}]},{"title":"深度剖析：如何实现一个 Virtual DOM 算法","date":"2017-12-08T06:45:15.000Z","path":"2017/12/08/virtual-dom/","text":"载自 《深度剖析：如何实现一个 Virtual DOM 算法》 —— Livoras 前言本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。 本文所实现的完整代码存放在 Github。 对前端应用状态管理的思考假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。 sort-table.png 这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据： 123var sortKey = \"new\" // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数var sortType = 1 // 升序还是逆序var data = [&#123;...&#125;, &#123;...&#125;, &#123;..&#125;, ..] // 表格数据 用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。 这样做会导致的后果就是，随着应用程序越来越复杂，需要在 JS 里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的 DOM 操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是 DOM 操作），你需要操作的 DOM 还是需要操作，只是换了个地方。 既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看这篇介绍）。 MVVM 可以很好的降低我们维护状态 -&gt; 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在 JS 里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下innerHTML就完事了。 听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，input和textarea的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（ Backbone 就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。 但是这里要明白和记住这种做法，因为后面你会发现，其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。 另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：维护状态，更新视图。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。 Virtual DOM算法DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到： dom-attributes 而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。 相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来： 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;, ]&#125; 上面对应的HTML写法是： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的 DOM 树。 之前的章节所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。 这就是所谓的 Virtual DOM 算法。包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的 DOM 树上，视图就更新了 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 算法实现步骤一：用JS对象模拟DOM树用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js 123456789function Element (tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children&#125;module.exports = function (tagName, props, children) &#123; return new Element(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element')var ul = el('ul', &#123;id: 'list'&#125;, [ el('li', &#123;class: 'item'&#125;, ['Item 1']), el('li', &#123;class: 'item'&#125;, ['Item 2']), el('li', &#123;class: 'item'&#125;, ['Item 3'])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的&lt;ul&gt;： 1234567891011121314151617181920Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) &#123; // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的 DOM 节点，把它塞入文档中，这样body里面就有了真正的&lt;ul&gt; 的DOM结构： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 完整代码可见 element.js。 步骤二：比较两棵虚拟DOM树的差异正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动 DOM 元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： compare-in-level 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 深度优先遍历，记录差异在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： dfs-walk 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是 0，那么： 1patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 差异类型上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点 2 内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;] 如果给div新增了属性id为container，就记录下： 123456789patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;, &#123; type: PROPS, props: &#123; id: \"container\" &#125;&#125;] 如果是文本节点，如上面的文本节点2，就记录下： 1234patches[2] = [&#123; type: TEXT, content: \"Virtual DOM2\"&#125;] 那如果把我div的子节点重新排序呢？例如p,ul,div的顺序换成了div,p,ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。 列表对比算法假设现在可以英文字母唯一地标识每一个子节点： 旧的节点顺序： 1a b c d e f g h i 现在对节点进行了删除、插入、移动的操作。新增j节点，删除e节点，移动h节点： 新的节点顺序： 1a b c h d f g i j 现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定 DOM 操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： 1234patches[0] = [&#123; type: REORDER, moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]&#125;] 但是要注意的是，因为tagName是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识key，列表对比的时候，使用key进行对比，这样才能复用老的 DOM 树上的节点。 这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。 步骤三：把差异应用到真正的DOM树上因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。 123456789101112131415161718192021function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点 var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; if (currentPatches) &#123; applyPatches(node, currentPatches) // 对当前节点进行DOM操作 &#125;&#125; applyPatches，根据不同类型的差异对当前节点进行 DOM 操作： 1234567891011121314151617181920function applyPatches (node, currentPatches) &#123; currentPatches.forEach(function (currentPatch) &#123; switch (currentPatch.type) &#123; case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 完整代码可见 patch.js。 结语Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用： 1234567891011121314151617181920212223// 1. 构建虚拟DOMvar tree = el('div', &#123;'id': 'container'&#125;, [ el('h1', &#123;style: 'color: blue'&#125;, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li')])])// 2. 通过虚拟DOM构建真正的DOMvar root = tree.render()document.body.appendChild(root)// 3. 生成新的虚拟DOMvar newTree = el('div', &#123;'id': 'container'&#125;, [ el('h1', &#123;style: 'color: red'&#125;, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li'), el('li')])])// 4. 比较两棵虚拟DOM树的不同var patches = diff(tree, newTree)// 5. 在真正的DOM元素上应用变更patch(root, patches) 当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。 本文所实现的完整代码存放在 Github，仅供学习。 Referenceshttps://github.com/Matt-Esch/virtual-dom/blob/master/vtree/diff.js","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"virtual-dom","slug":"virtual-dom","permalink":"http://xyue.me/tags/virtual-dom/"}]},{"title":"js 代码重构细节","date":"2017-12-06T07:30:41.000Z","path":"2017/12/06/js-restructure-points/","text":"重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 伴随软件的迭代，功能的日益复杂，由于没有理解原来程序的结构和考虑代码的扩展性，程序慢慢的失去了原来的结构，之前的设计变得面目全非。如果不进行重构，程序就会越来越难以维护。 为何重构 改进软件设计 —— 原来的设计没考虑到一些未知的情况，导致其后加入的功能破坏原有设计 使软件更容易理解 帮助找到bug —— 重构可以增加对代码的理解，从而更容易 提高编程速度 —— 重构虽然花费时间，但重构可以改善程序的设计，使添加新特性更容易 何时重构重构应该随时进行，当加入新功能时不是特别容易时，可以通过重构使添加新特性更容易，修补错误时更容易发现Bug，复审代码也是重构的好时机。 重构细节在实际的项目重构有一些常见而容易忽略的细节，这些细节也是帮助我们达到重构目标的重要手段。有一部分思想来自 Martin Fowler 的名著 《重构：改善既有代码的设计》，虽然该书是使用 Java 语言写成的，但这些重构的技巧，有很大一部分可以为 JavaScript 语言所借鉴。 提炼函数如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另外一个独立的函数中。这是一种很常见的优化工作，这样做的好处主要有以下几点。 避免出现超大函数 独立出来的函数有助于代码复用 独立出来的函数更容易被覆写 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用 1234567var getUserInfo = function () &#123; ajax('http:// xxx.com/userInfo', function (data) &#123; console.log('userId: ' + data.userId); console.log('userName: ' + data.userName); console.log('nickName: ' + data.nickName); &#125;);&#125;; 更改为↓ 12345678910var getUserInfo = function () &#123; ajax('http:// xxx.com/userInfo', function (data) &#123; printDetails(data); &#125;);&#125;;var printDetails = function (data) &#123; console.log('userId: ' + data.userId); console.log('userName: ' + data.userName); console.log('nickName: ' + data.nickName);&#125;; 合并重复的条件片段1234567891011var paging = function (currPage) &#123; if (currPage &lt;= 0) &#123; currPage = 0; jump(currPage); // 跳转 &#125; else if (currPage &gt;= totalPage) &#123; currPage = totalPage; jump(currPage); // 跳转 &#125; else &#123; jump(currPage); // 跳转 &#125;&#125;; 更改为↓ 12345678var paging = function (currPage) &#123; if (currPage &lt;= 0) &#123; currPage = 0; &#125; else if (currPage &gt;= totalPage) &#123; currPage = totalPage; &#125; jump(currPage); // 把 jump 函数独立出来&#125;; 把条件分支语句提炼成函数1234567var getPrice = function (price) &#123; var date = new Date(); if (date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9) &#123; // 夏天 return price * 0.8; &#125; return price;&#125;; 更改为↓ 12345678910var isSummer = function () &#123; var date = new Date(); return date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9;&#125;;var getPrice = function (price) &#123; if (isSummer()) &#123; // 夏天 return price * 0.8; &#125; return price;&#125;; 合理使用循环12345678910111213var createXHR = function () &#123; var xhr; try &#123; xhr = new ActiveXObject('MSXML2.XMLHttp.6.0'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('MSXML2.XMLHttp.3.0'); &#125; catch (e) &#123; xhr = new ActiveXObject('MSXML2.XMLHttp'); &#125; &#125; return xhr;&#125;; 更改为↓ 123456789var createXHR = function () &#123; var versions = ['MSXML2.XMLHttp.6.0ddd', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp']; for (var i = 0, version; version = versions[i++];) &#123; try &#123; return new ActiveXObject(version); &#125; catch (e) &#123; &#125; &#125;&#125;; 提前让函数退出代替嵌套条件分支1234567891011var del = function (obj) &#123; var ret; if (!obj.isReadOnly) &#123; // 不为只读的才能被删除 if (obj.isFolder) &#123; // 如果是文件夹 ret = deleteFolder(obj); &#125; else if (obj.isFile) &#123; // 如果是文件 ret = deleteFile(obj); &#125; &#125; return ret;&#125;; 更改为↓ 1234567891011var del = function (obj) &#123; if (obj.isReadOnly) &#123; // 反转 if 表达式 return; &#125; if (obj.isFolder) &#123; return deleteFolder(obj); &#125; if (obj.isFile) &#123; return deleteFile(obj); &#125;&#125;; 传递对象参数代替过长的参数列表12345678var setUserInfo = function (id, name, address, sex, mobile, qq) &#123; console.log('id= ' + id); console.log('name= ' + name); console.log('address= ' + address); console.log('sex= ' + sex); console.log('mobile= ' + mobile); console.log('qq= ' + qq);&#125;; 更改为↓ 12345678var setUserInfo = function (obj) &#123; console.log('id= ' + obj.id); console.log('name= ' + obj.name); console.log('address= ' + obj.address); console.log('sex= ' + obj.sex); console.log('mobile= ' + obj.mobile); console.log('qq= ' + obj.qq);&#125;; 尽量减少参数数量1var draw = function (width, height, square) &#123;&#125;; 更改为↓ 123var draw = function (width, height) &#123; var square = width * height;&#125;; 少用三目运算符如果条件分支逻辑简单且清晰，这无碍我们使用三目运算符：1var global = typeof window !== \"undefined\" ? window : this; 但如果条件分支逻辑非常复杂，如下段代码所示，那我们最好的选择还是按部就班地编写 if、 else。 if、 else 语句的好处很多，一是阅读相对容易，二是修改的时候比修改三目运算符周围的代码更加方便 123456789if ( !aup || !bup ) &#123; // 头痛吧 return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) : 0;&#125; 合理使用链式调用12345678910111213var User = function () &#123; this.id = null; this.name = null;&#125;;User.prototype.setId = function (id) &#123; this.id = id; return this;&#125;;User.prototype.setName = function (name) &#123; this.name = name; return this;&#125;;console.log(new User().setId(1314).setName('sven')); 或则↓ 12345678910111213var User = &#123; id: null, name: null, setId: function (id) &#123; this.id = id; return this; &#125;, setName: function (name) &#123; this.name = name; return this; &#125;&#125;;console.log(User.setId(1314).setName('sven')); 分解大型类12345678910111213var Spirit = function (name) &#123; this.name = name;&#125;;Spirit.prototype.attack = function (type) &#123; // 攻击 if (type === 'waveBoxing') &#123; console.log(this.name + ': 使用波动拳'); &#125; else if (type === 'whirlKick') &#123; console.log(this.name + ': 使用旋风腿'); &#125;&#125;;var spirit = new Spirit('RYU');spirit.attack('waveBoxing'); // 输出： RYU: 使用波动拳spirit.attack('whirlKick'); // 输出： RYU: 使用旋风腿 更改为↓ 123456789101112131415161718192021222324var Attack = function (spirit) &#123; this.spirit = spirit;&#125;;Attack.prototype.start = function (type) &#123; return this.list[type].call(this);&#125;;Attack.prototype.list = &#123; waveBoxing: function () &#123; console.log(this.spirit.name + ': 使用波动拳'); &#125;, whirlKick: function () &#123; console.log(this.spirit.name + ': 使用旋风腿'); &#125;&#125;;var Spirit = function (name) &#123; this.name = name; this.attackObj = new Attack(this);&#125;;Spirit.prototype.attack = function (type) &#123; // 攻击 this.attackObj.start(type);&#125;;var spirit = new Spirit('RYU');spirit.attack('waveBoxing'); // 输出： RYU: 使用波动拳spirit.attack('whirlKick'); // 输出： RYU: 使用旋风腿 用 return 退出多重循环123456789101112131415var func = function () &#123; var flag = false; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; flag = true; break; &#125; &#125; if (flag === true) &#123; break; &#125; &#125; console.log('....');&#125;; 更改为↓ 12345678910var func = function () &#123; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; console.log('....'); // for 循环后边的代码提取到 return 之前执行 return; &#125; &#125; &#125;&#125;; References《JavaScript设计模式与开发实践》——曾探","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"},{"name":"重构","slug":"重构","permalink":"http://xyue.me/tags/重构/"}]},{"title":"ionic3 启动白屏解决","date":"2017-11-27T09:25:06.000Z","path":"2017/11/27/ionic-start-white-screen/","text":"问题描述APP 启动后，会有一段时间的白屏，影响体验 解决第一步向 config.xml 配置文件中添加以下内容 1234&lt;preference name=\"AutoHideSplashScreen\" value=\"false\" /&gt; &lt;!-- 禁止自动隐藏 --&gt;&lt;preference name=\"ShowSplashScreen\" value=\"true\" /&gt; &lt;!-- 显示启动画面 --&gt;&lt;preference name=\"ShowSplashScreenSpinner\" value=\"true\" /&gt; &lt;!-- 显示启动加载灰圈 --&gt;&lt;preference name=\"FadeSplashScreen\" value=\"true\" /&gt; &lt;!-- 启动淡出效果 --&gt; 第二步向 /src/app/main.ts 文件中添加以下内容 12import &#123; enableProdMode &#125; from '@angular/core';enableProdMode();// 加快启动速度 完成以上步骤重新 build.","tags":[{"name":"ionic","slug":"ionic","permalink":"http://xyue.me/tags/ionic/"}]},{"title":"全文检索引擎 Solr 搭建","date":"2017-10-18T01:43:31.000Z","path":"2017/10/18/search-engine-solr-build/","text":"Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。 准备配置环境 window JDK 1.8 Solr 7.0.1 oracle 目录说明下载Solr后解压得到目录 12345678910├─bin // 脚本的启动目录├─contrib // 第三方 jar 包存放目录├─dist // 编译打包后存放目录，即构建后的输出产物存放目录├─docs // solr 的 API 文档文档存放目录├─example // 示范例子的存放目录，example-DIH 目录下的是一些 solr 索引 core 样例├─licenses // solr 相关的一些许可信息└─server // solr 服务端工作目录，自带集成 jetty 插件方式启动 solr 服务器 │ start.jar // 服务端启动 jar 包 ├─solr // solr 搜索引擎工作目录，即 SOLRHOME └─solr-webapp // solr 后台管理页面 webapp 启动进入 /bin 目录， 按住 shift + 鼠标右键打开命令窗口 打开命令窗口 输入 1solr start 启动 Solr 服务 启动 Solr 服务 在浏览器中输入 localhost:8983 访问 Solr 管理后台 管理后台 新建索引库core输入 1solr create -c my_core 新建名为 my_core 的 core create 创建成功后，在管理页面选择 Core Admin 可以看到刚创建的 core 在 SOLRHOME （目录说明中有提到）下会生成 my_core 目录 my_core 1234├─conf // 存放core的配置文件│ solrconfig.xml // 定义了这个 core 的配置信息│ start.jar // 定义索引库的字段及分词器等，这个配置文件是核心文件└─data // 存放core的数据，即index-索引文件和log-日志记录 导入数据导入 oracle 表 news 中的数据 table_news 在 %SOLRHOME%/my_core/conf 目录下创建 data-config.xml 文件，并写入以下内容 123456789101112131415&lt;dataConfig&gt; &lt;dataSource user=\"[user]\" password=\"[password]\" url=\"jdbc:oracle:thin:@[host]:[port]:[SID]\" driver=\"oracle.jdbc.driver.OracleDriver\"/&gt; &lt;document &gt; &lt;!-- 表中字段映射 pk: 主键 transformer： clob 转换 --&gt; &lt;entity name=\"news\" pk=\"ID\" query=\"select * from news\" transformer=\"ClobTransformer\"&gt; &lt;field name=\"id\" column=\"N_ID\"/&gt; &lt;field name=\"title\" column=\"N_TITLE\"/&gt; &lt;field name=\"content\" column=\"N_CONTENT\" clob=\"true\"/&gt; &lt;field name=\"time\" column=\"N_TIME\"/&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; 在 %SOLRHOME%/my_core 下创建 lib 文件夹，并将 oracle 驱动包 ojdbc6.jar 放到该目录下此时 my_core 文件结构如下 123456789101112131415│ core.properties│ ├─conf│ │ data-config.xml│ │ dataimport.properties│ │ managed-schema│ │ params.json│ │ protwords.txt│ │ solrconfig.xml│ │ stopwords.txt│ │ synonyms.txt│ └─lang ├─data └─lib ojdbc6.jar 编辑 %SOLRHOME%/my_core/conf/solrconfig.xml，添加类库和数据库配置： 1&lt;lib dir=\"$&#123;solr.install.dir:../../../..&#125;/dist/\" regex=\"solr-dataimporthandler-\\d.*\\.jar\" /&gt; 12345&lt;requestHandler name=\"/dataimport\" class=\"solr.DataImportHandler\"&gt; &lt;lst name=\"defaults\"&gt; &lt;str name=\"config\"&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt; &lt;/requestHandler&gt; 选择当前 my_core ,选择 Schema, 添加索引字段 （字段名称和 solrconfig.xml 中 field 相同，忽略主键） Add Filed 添加完成后，打开 %SOLRHOME%/my_core/conf/managed-schema，可以看到，此时添加索引字段已写入该文件中 managed-schema 在命令台中输入1solr restart -p 8983 重启服务 restart 进入管理界面，选择 my_core –&gt; Dataimport –&gt; Execute 导入数据，可以点击 Refresh Status 查看导入状态 Dataimport 查询数据选择 Query Query 点击 Execute Query 查询数据 Execute Query 分词器smartcn 、 IKAnalyzer 、 mmseg4j，选择其中任意一种即可 smartcnsmartcn 是 Solr 同步发行的一个中文分词包，将 solr-7.0.1/contrib/analysis-extras/lucene-libs/lucene-analyzers-smartcn-7.0.1.jar 拷贝至 %SOLRHOME%/my_core/lib，编辑 %SOLRHOME%/my_core/conf/managed-schema 文件，添加配置 12345678910&lt;!-- smartcn --&gt;&lt;fieldType name=\"text_smartcn\" class=\"solr.TextField\" positionIncrementGap=\"0\"&gt; &lt;analyzer type=\"index\"&gt; &lt;tokenizer class=\"org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory\"/&gt; &lt;/analyzer&gt; &lt;analyzer type=\"query\"&gt; &lt;tokenizer class=\"org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory\"/&gt; &lt;/analyzer&gt;&lt;/fieldType&gt;&lt;!-- smartcn --&gt; IKAnalyzer IKAnalyzer 是一个开源的，基于 java 语言开发的轻量级的中文分词工具包。 将 ik-analyzer-solr5 打包后放至 %SOLRHOME%/my_core/lib 下编辑 %SOLRHOME%/my_core/conf/managed-schema 文件，添加配置 123456&lt;!-- IKAnalyzer --&gt;&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer type=\"index\" isMaxWordLength=\"false\" class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/&gt; &lt;analyzer type=\"query\" isMaxWordLength=\"true\" class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/&gt;&lt;/fieldType&gt;&lt;!-- IKAnalyzer --&gt; mmseg4j mmseg4j 用 Chih-Hao Tsai 的 MMSeg 算法 实现的中文分词器，并实现 lucene 的 analyzer 和 solr 的TokenizerFactory 以方便在Lucene和Solr中使用。 MMSeg 算法有两种分词方法： Simple 和 Complex，都是基于正向最大匹配。 mmseg4j 有三种分词模式 simple | complex | max-word，默认是 max-word。 mmseg4j 的词库强制使用 UTF-8。 下载需要的包 mmseg4j-core-1.10.0.jar mmseg4j-solr-2.4.0.jar 放至 %SOLRHOME%/my_core/lib 中编辑 %SOLRHOME%/my_core/conf/managed-schema 文件，添加配置 1234567891011121314151617&lt;!-- mmseg4j--&gt;&lt;fieldType name=\"text_mmseg4j_complex\" class=\"solr.TextField\" positionIncrementGap=\"100\" &gt; &lt;analyzer&gt; &lt;tokenizer class=\"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory\" mode=\"complex\"/&gt; &lt;/analyzer&gt;&lt;/fieldType&gt;&lt;fieldType name=\"text_mmseg4j_maxword\" class=\"solr.TextField\" positionIncrementGap=\"100\" &gt; &lt;analyzer&gt; &lt;tokenizer class=\"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory\" mode=\"max-word\" /&gt; &lt;/analyzer&gt;&lt;/fieldType&gt;&lt;fieldType name=\"text_mmseg4j_simple\" class=\"solr.TextField\" positionIncrementGap=\"100\" &gt; &lt;analyzer&gt; &lt;tokenizer class=\"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory\" mode=\"simple\" /&gt; &lt;/analyzer&gt;&lt;/fieldType&gt;&lt;!-- mmseg4j--&gt; 重启服务 Analysis分词器配置完成后，选择 Analysis，输入要分词的内容（Field Value），选择字段类型（Analyse Fieldname / FieldType [与配置信息 fieldType name 同步]），点击 Analyse Values 获取分词结果。 Analyse Values 编辑 %SOLRHOME%/my_core/conf/managed-schema，修改索引字段类型为新添加分词类型其中任意一种即可，这里我们将 text_general 修改为 text_ik，重启服务后重新导入数据 Modify Type 这样我们在对该字段行进搜索时就能达到分词搜索的效果了😛","tags":[{"name":"solr","slug":"solr","permalink":"http://xyue.me/tags/solr/"}]},{"title":"使用 UEditor(JSP 1.4.3版本) 遇到的问题","date":"2017-10-12T09:02:01.000Z","path":"2017/10/12/problems-of-using-ueditor/","text":"ueditor简介: UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码… 遇到问题及解决方案setContent报错描述当使用setContent给初始化容器设置内容时出现如下错误： 原因异步，初始化容器并未创建完成，需等待编辑器创建完成后才能使用。 解决方法一使用setTimeout延迟一段时间后调用（不建议：由于setTimeout设置的时间与实际渲染需要的时间不一致）； 方法二使用addListener(‘ready’,callback)，待编辑器创建完成后执行callback回调。123ue.addListener('ready', function () &#123; ue.setContent(content);&#125;); 上传文件——“未找到上传数据”描述无论上传什么文件均出现如下错误： 原因 struts2：struts2 框架默认使用 apache 的 commons-fileUpload 组件和内建的 FileUploadInterceptor 拦截器实现上传，会将 request 文件域封装到 action 中一个 File 类型的属性中，并删除 request 中的文件域，因此会上传文件失败。 springMVC：UEditor 默认使用 commons 组件，而 springMVC 对 commons 组件进行了封装，使得上传后获取不到文件。 解决 struts2：自定义一个 struts 过滤器，指定不对 ueditor/jsp/ 目录下的 jsp 页面进行过滤。 12345678910111213141516public class MyStrutsFilter extends StrutsPrepareAndExecuteFilter&#123; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; String url = request.getRequestURI(); System.out.println(url); if (url.contains(request.getContextPath()+\"/js/utf8-jsp/jsp/controller.jsp\")) &#123; System.out.println(\"使用自定义过滤器\"); chain.doFilter(req, res); &#125;else&#123; System.out.println(\"使用默认过滤器\"); super.doFilter(req, res, chain); &#125; &#125;&#125; springMVC：修改源码 upload 包下的 BinaryUploader.java 文件。下载并使用源码： 重写 BinaryUploader.java ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BinaryUploader &#123; public static final State save(HttpServletRequest request,Map&lt;String, Object&gt; conf) &#123; InputStream fileStream = null; if (!ServletFileUpload.isMultipartContent(request)) &#123; return new BaseState(false, AppInfo.NOT_MULTIPART_CONTENT); &#125; try &#123; //修改了百度使用原生的commons上传方式 DefaultMultipartHttpServletRequest multipartRequest=(DefaultMultipartHttpServletRequest)request; Iterator&lt;String&gt; fileNames=multipartRequest.getFileNames(); MultipartFile file=null; while (fileNames.hasNext())&#123; file=multipartRequest.getFiles(fileNames.next()).get(0); fileStream=file.getInputStream(); &#125; if (fileStream == null) &#123; return new BaseState(false, AppInfo.NOTFOUND_UPLOAD_DATA); &#125; String savePath = (String) conf.get(\"savePath\"); String originFileName = file.getOriginalFilename(); String suffix = FileType.getSuffixByFilename(originFileName); originFileName = originFileName.substring(0,originFileName.length() - suffix.length()); savePath = savePath + suffix; long maxSize = ((Long) conf.get(\"maxSize\")).longValue(); if (!BinaryUploader.validType(suffix, (String[]) conf.get(\"allowFiles\"))) &#123; return new BaseState(false, AppInfo.NOT_ALLOW_FILE_TYPE); &#125; savePath = PathFormat.parse(savePath, originFileName); String physicalPath = (String) conf.get(\"rootPath\") + savePath; State storageState = StorageManager.saveFileByInputStream(fileStream,physicalPath, maxSize); fileStream.close(); if (storageState.isSuccess()) &#123; storageState.putInfo(\"url\", PathFormat.format(savePath)); storageState.putInfo(\"type\", suffix); storageState.putInfo(\"original\", originFileName + suffix); &#125; return storageState; &#125; catch (ClassCastException e) &#123; return new BaseState(false, AppInfo.PARSE_REQUEST_ERROR); &#125;catch (IOException e)&#123; return new BaseState(false, AppInfo.IO_ERROR); &#125; &#125; private static boolean validType(String type, String[] allowTypes) &#123; List&lt;String&gt; list = Arrays.asList(allowTypes); return list.contains(type); &#125;&#125; 上传文件消失描述使用 tomcat ，已上传文件在重新部署项目后丢失。 原因UEditor 上传配置文件 config.json 默认将上传文件上传到项目中，重新部署会清空项目文件。 解决方法一：修改上传路径到webapps目录下第一步：将配置文件中上传保存路径/ueditor/jsp/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}修改为/../ueditor/jsp/upload/image/{yyyy}{mm}{dd}/{time}{rand:6} 第二步：修改返回文件请求地址，将重写后 BinaryUploader.java 第33行的PathFormat.format(savePath)修改为PathFormat.format(savePath).replace(&quot;/..&quot;, &quot;&quot;) 方法二：配置 tomcat 虚拟目录第一步：打开 %TOMCAT_HOME%/conf/server.xml（即tomcat的安装目录下面相关的文件），在 Host 中加入如下代码：123&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Context path=\"/ueditor\" docBase=\"D:\\ueditor\" reloadable=\"true\"&gt;&lt;/Context&gt; &lt;/Host&gt; 第二步：修改上传路径，将重写后 BinaryUploader.java 第29行的(String) conf.get(&quot;rootPath&quot;) + savePath修改为&quot;D://&quot; + savePath 上传路径与虚拟目录 docBase 保持一致","tags":[{"name":"富文本编辑器","slug":"富文本编辑器","permalink":"http://xyue.me/tags/富文本编辑器/"},{"name":"UEditor","slug":"UEditor","permalink":"http://xyue.me/tags/UEditor/"}]},{"title":"Master-Worker 设计模式","date":"2017-09-30T07:02:36.000Z","path":"2017/09/30/master-worker-design/","text":"介绍Master-Worker是常用的并行计算模式。它的核心思想是系统由两类进程协作工作： Master进程：负责接收和分配任务 Worker进程：负责处理子任务 当各个Worker子进程处理完成后 ，会将结果返回给Master，由Master作归纳总结。其好处就是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。各角色关系如下图所示： Master进程为主要进程，它维护一个Worker进程队列、子任务队列和子结果集。Worker进程队列中的Worker进程不停从任务队列中提取要处理的子任务，并将结果写入结果集。 根据上面的思想，我们来模拟一下这种经典设计模式的实现。 分析过程 既然Worker是具体的执行任务，那么Worker一定要实现Runnable接口 Matser作为接受和分配任务，得先有个容器来装载用户发出的请求，在不考虑阻塞的情况下我们选择ConcurrentLinkedQueue作为装载容器 Worker对象需要能从Master接收任务，它也得有Master ConcurrentLinkedQueue容器的引用 Master还得有个容器需要能够装载所有的Worker，可以使用HashMap&lt;String,Thread&gt; Worker处理完后需要将数据返回给Master，那么Master需要有个容器能够装载所有worker并发处理任务的结果集。此容器需要能够支持高并发，所以最好采用ConcurrentHashMap&lt;String,Object&gt; 同理由于Worker处理完成后将数据填充进Master的ConcurrentHashMap，那么它也得有一份ConcurrentHashMap的引用 代码实现Task任务对象1234567891011121314151617181920212223242526272829public class Task &#123; private int id; private String name; private int price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125;&#125; Master对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Master &#123; //任务集合 private ConcurrentLinkedQueue&lt;Task&gt; taskQueue = new ConcurrentLinkedQueue&lt;&gt;(); //所有的处理结果 private ConcurrentHashMap&lt;String,Object&gt; resultMap = new ConcurrentHashMap&lt;&gt;(); //所有的Worker集合 private HashMap&lt;String,Thread&gt; workerMap = Maps.newHashMap(); //构造方法，初始化Worker public Master(Worker worker,int workerCount)&#123; //每一个worker对象都需要有Master的引用，taskQueue用于任务的提取，resultMap用于任务的提交 worker.setTaskQueue(this.taskQueue); worker.setResultMap(this.resultMap); for(int i = 0 ;i &lt; workerCount; i++)&#123; //key表示worker的名字,value表示线程执行对象 workerMap.put(\"worker\"+i,new Thread(worker)); &#125; &#125; //用于提交任务 public void submit(Task task)&#123; this.taskQueue.add(task); &#125; //执行方法，启动应用程序让所有的Worker工作 public void execute()&#123; for(Map.Entry&lt;String,Thread&gt; me : workerMap.entrySet())&#123; me.getValue().start(); &#125; &#125; //判断所有的线程是否都完成任务 public boolean isComplete() &#123; for(Map.Entry&lt;String,Thread&gt; me : workerMap.entrySet())&#123; if(me.getValue().getState() != Thread.State.TERMINATED)&#123; return false; &#125; &#125; return true; &#125; //总结归纳 public int getResult()&#123; int ret = 0; for (Map.Entry&lt;String, Object&gt; entry : resultMap.entrySet()) &#123; ret+=(Integer) entry.getValue(); &#125; return ret; &#125;&#125; Worker对象123456789101112131415161718192021222324252627282930313233343536public class Worker implements Runnable&#123; private ConcurrentLinkedQueue&lt;Task&gt; taskQueue; private ConcurrentHashMap&lt;String, Object&gt; resultMap; public void setTaskQueue(ConcurrentLinkedQueue&lt;Task&gt; taskQueue) &#123; this.taskQueue = taskQueue; &#125; public void setResultMap(ConcurrentHashMap&lt;String, Object&gt; resultMap) &#123; this.resultMap = resultMap; &#125; @Override public void run() &#123; while(true)&#123; Task executeTask = this.taskQueue.poll(); if(executeTask == null) break; //真正的任务处理 Object result = handle(executeTask); this.resultMap.put(executeTask.getName(),result); &#125; &#125; //核心处理逻辑，可以抽离出来由具体子类实现 private Object handle(Task executeTask) &#123; Object result = null; try &#123; //表示处理任务的耗时.... Thread.sleep(500); result = executeTask.getPrice(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; Client调用12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; //实际开发中多少个线程最好写成Runtime.getRuntime().availableProcessors() Master master = new Master(new Worker(), 10); Random random = new Random(); for(int i = 0 ;i &lt;= 100 ;i++)&#123; Task task = new Task(); task.setId(i); task.setName(\"任务\"+i); task.setPrice(random.nextInt(1000)); master.submit(task); &#125; master.execute(); long start = System.currentTimeMillis(); while(true)&#123; if(master.isComplete())&#123; long end = System.currentTimeMillis() - start; int ret = master.getResult(); System.out.println(\"计算结果:\"+ret+\",执行耗时:\"+end); break; &#125; &#125; &#125;&#125; 在Worker对象中的核心处理业务逻辑handle方法最好抽象成公共方法，具体实现由子类覆写。","tags":[{"name":"多线程","slug":"多线程","permalink":"http://xyue.me/tags/多线程/"},{"name":"设计模式","slug":"设计模式","permalink":"http://xyue.me/tags/设计模式/"},{"name":"java","slug":"java","permalink":"http://xyue.me/tags/java/"}]},{"title":"JS 中的值传递","date":"2017-09-12T02:12:17.000Z","path":"2017/09/12/value-passing-in-js/","text":"值传递?相信在看到这个标题时，很多童鞋都会有这样的疑惑——“What?不是还有引用传递么”。像这样：1234567var person = &#123; name : 'lilei' &#125;;function setName (obj) &#123; obj.name = 'hanmeimei'; console.log(obj.name); //output: hanmeimei&#125;setName(person);console.log(person.name); //output: hanmeimei 确实，对象person属性name的值被改变了，最初的我对此也是深信不疑。在《JavaScript高级程序设计》第三版 4.1.3中，关于参数的传递这样讲到： ECMAScript中所有函数的参数都是按值传递的。 啥子哎！连红宝书都这样说，那可得好好深究下。 定义在解开疑惑前，我们先了解下什么是按值传递(call by value)，什么是按引用传递(call by reference)。在计算机科学里，这个部分叫求值策略(Evaluation Strategy)。它决定变量之间、函数调用时实参和形参之间值是如何传递的。 传递方式 值传递(call by value)常用的求值策略，函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。 引用传递(call by reference)函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。 数据类型ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。 基本数据类型：保存在栈内存中的简单数据段，常见的基本数据类型 Number、String 、Boolean、Null和Undefined，最新的ECMAScript标准定义加入了Symbol。 引用数据类型：保存在堆内存中的由多个值构成的对象，比如：Array、Function和Object，从底层技术上看，它们三都是对象。与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 引用传递?如果一个基本数据类型绑定给某个变量，我们可以认为该变量包含这个基本数据类型的值。1234567var name = 'lilei';function setName (n) &#123; n = 'hanmeimei'; console.log(n); //output: hanmeimei&#125;setName(name);console.log(name); //output: lilei 当我们将新值重新赋给变量，可以看到这里 name 值并没有改变,实际上 n 只是保存了 name 复制的一个副本(函数的形参是被调用时所传实参的副本)。 变量 值 name lilei n lilei 所以，n 的改变对 name 没有影响。 变量 值 name lilei n hanmeimei 我们把它称作值传递。可以这样理解，当传递 name 到函数 setName 中，相当于拷贝了一份 name ，假设拷贝的这份叫 _name ，函数中修改的都是 _name 的值，而不会影响原来的 name 值。 回到最前边我们看到的那段代码，稍加改动:12345678var person = &#123; name : 'lilei' &#125;;function setName (obj) &#123; // obj.name = 'hanmeimei'; obj = &#123; name : 'hanmeimei' &#125;; console.log(obj.name); //output: hanmeimei&#125;setName(person);console.log(person.name); //output: lilei 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。但这里 obj 的改变并没有影响 person，这究竟是引用传递吗？ 解惑看到这，相信你对之前的理解已有了不一样的认识。既然这不是引用传递，还会是值传递么？ 基本数据类型传递值，引用数据类型传递引用地址(引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象)。 正如前边定义所提到的那样，值传递，函数的形参是被调用时所传实参的副本。不难理解，当 person 变量 值 地址 对象 person &lt;#001&gt; #001 { name : ‘lilei’ } 做为参数进入函数 setName 后，就有了地址副本，这个地址副本和 person 的地址指向是相同的。 变量 值 地址 对象 person &lt;#001&gt; #001 { name : ‘lilei’ } obj &lt;#001&gt; #001 &lt;#002&gt; #002 { name : ‘hanmeimei’ } 如果这个时候我们对这个副本操作改变其属性值，则指向这个地址的变量都会发生变化。但我们为 obj 重新赋了值，将地址副本指向改变，指向了新的对象。 变量 值 地址 对象 person &lt;#001&gt; #001 { name : ‘lilei’ } obj &lt;#002&gt; #002 { name : ‘hanmeimei’ } 这样一来 obj 和 person 就完全断了， obj 的改变并不会影响 person。 传递对象引用的副本，这样的传递方式又被称之为共享传递(call by sharing)。拷贝副本，也是一种值的拷贝，所以在JS中只有值传递。😉","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xyue.me/tags/javascript/"}]},{"title":"如何让元素里的 div 垂直居中","date":"2017-09-08T09:35:58.000Z","path":"2017/09/08/div-vertical-center/","text":"已知宽高元素绝对定位与负边距实现。利用绝对定位，将元素的top和left属性都设为50%，再利用margin边距，将元素回拉它本身高宽的一半，实现垂直居中。 123456789101112#container &#123; position:relative;&#125;#div &#123; position:absolute; width: x; height: y; top: 50%; left: 50%; margin: -x / 2 0 0 -y / 2;&#125; 未知宽高元素方法一使用绝对定位与margin。 123456789101112#container &#123; position:relative;&#125;#div &#123; position: absolute; margin: 0 auto; top: 0; bottom: 0; left: 0; right: 0;&#125; 方法二当要被居中的元素是内联元素的时候，将父级容器设置为display:table-cell，配合text-align:center和vertical-align:middle即可以实现水平垂直居中。 12345#container &#123; display:table-cell; text-align:center; vertical-align:middle;&#125; 方法三使用css3的transform。 12345678910#container &#123; position:relative;&#125; #div &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 方法四使用flex布局。 12345#container &#123; display:flex; justify-content:center; align-items: center;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://xyue.me/tags/css/"},{"name":"居中","slug":"居中","permalink":"http://xyue.me/tags/居中/"}]}]