<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>纯 CSS 实现多行省略</title>
    <url>/2020/06/28/read-more-content/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/06/28/read-more-content/header-img.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="什么是多行省略"><a href="#什么是多行省略" class="headerlink" title="什么是多行省略"></a>什么是多行省略</h2><p>当字数达到一定程度超出限制行数就会显示省略号。</p>
<h2 id="webkit-line-clamp"><a href="#webkit-line-clamp" class="headerlink" title="-webkit-line-clamp"></a>-webkit-line-clamp</h2><p>我们可以使用 <code>-webkit-line-clamp</code> 简单实现。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">overflow </span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/06/28/read-more-content/2-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>但 <code>-webkit-line-clamp</code> 是一个不规范的属性（unsupported WebKit property），它并没有出现在 <code>CSS</code> 规范草案中。因此这个方案并不完美。</p>
<h2 id="一般方案"><a href="#一般方案" class="headerlink" title="一般方案"></a>一般方案</h2><ol>
<li>通过脚本截取内容获取高度判断显隐查看更多</li>
<li>换行显示，在新的一行显示查看更多</li>
</ol>
<h2 id="新的方案"><a href="#新的方案" class="headerlink" title="新的方案"></a>新的方案</h2><p>利用右浮动原理——右浮动元素从右到左依次排列，不够空间则换行。蓝色块、红色块、绿色块依次右浮动，蓝色块高度小于 6 行文字时，绿色块在右边，蓝色块高度大于等于 6 行文字时，左下角刚好够绿色块排列的空间，于是绿色块就到左边了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/06/28/read-more-content/3-1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"contain"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容容内容内容内容内容内容内容内容内容内容内容内容内容内容容内容内容内容内容内容内容内容内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"placeholder"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"more"</span>&gt;</span>...更多<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@-webkit-keyframes</span> width-change &#123;</span><br><span class="line">  0%,</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.contain</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: width-change <span class="number">8s</span> ease infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.more</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100%</span>, -<span class="number">100%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以稍作改动：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">.more &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  float: right;</span><br><span class="line">  width: 80px;</span><br><span class="line">  height: 20px;</span><br><span class="line">  background: rgba(0, 255, 0, 1);</span><br><span class="line"><span class="addition">+ left: 100%;</span></span><br><span class="line"><span class="addition">+ transform: translate(-100%, -100%);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/06/28/read-more-content/3-2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这样 <code>更多</code> 就移动到了我们预设的位置，通过文字溢出截断就达到我们最终想要的效果。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">.contain &#123;</span><br><span class="line">  line-height: 20px;</span><br><span class="line">  animation: width-change 8s ease infinite;</span><br><span class="line"><span class="addition">+ max-height: 100px;</span></span><br><span class="line"><span class="addition">+ overflow: hidden;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/06/28/read-more-content/3-3.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<iframe height="265" style="width: 100%;" scrolling="no" title="ellipsis" src="https://codepen.io/fuzhongyi/embed/wvMEpyv?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/fuzhongyi/pen/wvMEpyv" target="_blank" rel="noopener">ellipsis</a> by 歆月<br>  (<a href="https://codepen.io/fuzhongyi" target="_blank" rel="noopener">@fuzhongyi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await 实现原理</title>
    <url>/2020/05/29/async-await-realize/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'Promisem 1'</span>), <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'Promisem 2'</span>), <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data1 = <span class="keyword">await</span> p1();</span><br><span class="line">  <span class="built_in">console</span>.log(data1);</span><br><span class="line">  <span class="keyword">var</span> data2 = <span class="keyword">await</span> p2();</span><br><span class="line">  <span class="built_in">console</span>.log(data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'end'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'Promisem 1'</span>), <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'Promisem 2'</span>), <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data1 = <span class="keyword">yield</span> p1();</span><br><span class="line">  <span class="built_in">console</span>.log(data1);</span><br><span class="line">  <span class="keyword">var</span> data2 = <span class="keyword">yield</span> p2();</span><br><span class="line">  <span class="built_in">console</span>.log(data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'end'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncToGenerator</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen.apply(<span class="keyword">this</span>, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = g.next(val);</span><br><span class="line">      <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">        resolve(result.value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(result.value).then(step, reject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncToGenerator(test).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看尽 redux，中间件设计实现</title>
    <url>/2020/04/15/react-redux-middleware/</url>
    <content><![CDATA[<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p><code>React</code> 作为一个组件化开发框架，组件之间存在大量通信，有时这些通信跨越多个组件，或者多个组件之间共享一套数据，简单的父子组件间传值不能满足我们的需求，自然而然地，我们需要有一个地方存取和操作这些公共状态。而 <code>redux</code> 就为我们提供了这样一种管理公共状态的方案。</p>
<p>了解了什么是 <code>redux</code>，以及它的到来为我们解决了什么问题，我们围绕这一功能，逐步实现。</p>
<p>既然是公共状态，那么我们创建这样一个文件 <code>store.js</code>，然后直接在里边存放公共的 state，其他组件只要引入这个 store 就可以存取共用状态了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们并不能这样去设计，主要原因有 2 点：</p>
<ul>
<li>容易误操作 - 其他任何地方均可以修改 state，这样做显然不太安全 出错了也很难排查，因此我们需要有条件地操作 store，防止使用者直接修改 store 的数据</li>
<li>可读性很差 - js 是一门极其依赖语义化的语言，试想如果在代码中不经注释直接修改了公用的 state，难以维护，为了搞清楚修改 state 的含义还得根据上下文推断，所以我们最好是给每个操作起个名字</li>
</ul>
<p>思考：</p>
<p>我们希望公共状态既能够被全局访问到，又是私有的不能被直接修改，闭包完全满足这两条要求，因此我们会把公共状态设计成闭包。</p>
<p>既然我们要存取状态，那么肯定要有 <code>getter</code> 和 <code>setter</code>，此外当状态发生改变时，我们得进行广播，通知组件状态发生了变更。</p>
<p>这不就和 <code>redux</code> 的三个 api：<code>getState</code>、<code>dispatch</code>、<code>subscribe</code> 对应上了吗。</p>
<p>我们用几句代码勾勒出 store 的大致形状：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;   <span class="comment">// 公共状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// getter</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// setter</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 发布订阅</span></span><br><span class="line">    <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getState-实现"><a href="#getState-实现" class="headerlink" title="getState 实现"></a>getState 实现</h3><p><code>getState()</code> 的实现非常简单，返回当前状态即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;   <span class="comment">// 公共状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// getter</span></span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// setter</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 发布订阅</span></span><br><span class="line">    <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-实现"><a href="#dispatch-实现" class="headerlink" title="dispatch 实现"></a>dispatch 实现</h3><p>经过上面的分析，我们的目标是有条件地、具名地修改 store 的数据。所以这里我们像 redux 中 dispatch 那样传入一个 action 对象，这个对象包含操作类型 type，根据 type 的不同对应修改返回不同的 state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'plus'</span>:</span><br><span class="line">            currentState = &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                count: currentState.count + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样我们把执行逻辑写在了 dispatch 中，耦合度太高，于是我们想到把这部分代码抽离出来放到外面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">       currentState = reducer(currentState, action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不就是我们熟悉的 <code>reducer</code> 吗，然后我们创建一个 reducer.js 文件，写我们的 reducer。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'plus'</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'subtract'</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> initialState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写到这里，我们可以验证一下 <code>getState</code> 和 <code>dispatch</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reducer &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)  <span class="comment">// 创建store</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'plus'</span> &#125;)    <span class="comment">// 执行加法操作，给 count 加 1</span></span><br><span class="line"><span class="built_in">console</span>.log(store.getState())       <span class="comment">// 获取 state</span></span><br></pre></td></tr></table></figure>
<p>运行代码，我们会发现，打印得到的 state 是：<code>{ count: NaN }</code>。这是因为，store 中 state 的初始数据为 {}， <code>state.count + 1</code> 实际上是 <code>underfind + 1</code>。</p>
<p>所以我们得先进行 state 数据的初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">       currentState = reducer(currentState, action)</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'@STATE_INIT@'</span>&#125;); <span class="comment">// 初始化 state 数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就能得到正确的 state：<code>{ count: 1 }</code>。</p>
<h3 id="subscribe-实现"><a href="#subscribe-实现" class="headerlink" title="subscribe 实现"></a>subscribe 实现</h3><p>尽管我们已经能够存取公用 state，但 store 的变化并不会直接引起视图的更新，我们需要监听 store 的变化。每次 dispatch，都进行广播，通知组件 store 的状态发生了变更，这里我们应用一个设计模式——观察者模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> observers = []          <span class="comment">// 观察者队列</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">       currentState = reducer(currentState, action)</span><br><span class="line">       observers.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'@STATE_INIT@'</span>&#125;); <span class="comment">// 初始化 state 数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        observers.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)  </span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'组件 1 收到 store 的通知'</span>) &#125;)</span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'组件 2 收到 store 的通知'</span>) &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'plus'</span> &#125;) <span class="comment">// 执行 dispatch，触发 store 的通知</span></span><br></pre></td></tr></table></figure>
<p>到这里，一个简单的 redux 就已经完成。</p>
<p>但我们在使用 store 时，需要在每个组件中 <code>import</code> 引入 store，然后获取状态<code>(getState)</code>，修改状态<code>(dispatch)</code> ，订阅更新<code>(subscribe)</code>，代码比较冗余，我们需要合并一些重复操作，而其中一种简化合并的方案，就是我们熟悉的 <code>react-redux</code>。</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>上文我们说到，一个组件如果想从 store 存取公用状态，需要进行四步操作。</p>
<p>react-redux 提供 <code>Provider</code> 和 <code>connect</code> 两个 API，<code>Provider</code> 将 <code>store</code> 放进 <code>this.context</code> 里，省去了 <code>import</code> 这一步，<code>connect</code> 将 <code>getState</code>、<code>dispatch</code> 合并进了 <code>this.props</code>，并自动订阅更新，简化了另外三步，下面我们来看一下如何实现这两个 API：</p>
<h3 id="Provider-实现"><a href="#Provider-实现" class="headerlink" title="Provider 实现"></a>Provider 实现</h3><p>Provider 是一个组件，接收 store 并将其放进全局 context。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 需要声明静态属性 childContextTypes 来指定 context 对象的属性，是 context 的固定写法  </span></span><br><span class="line">    <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">        store: PropTypes.object  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 getChildContext 方法，返回 context 对象，也是固定写法  </span></span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props, context)</span><br><span class="line">        <span class="keyword">this</span>.store = props.store  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染被 Provider 包裹的组件  </span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成 Provider 后，我们就不需要再单独 import store，可直接在组件中通过 <code>this.context.store</code> 取到 store。</p>
<h3 id="connect-实现"><a href="#connect-实现" class="headerlink" title="connect 实现"></a>connect 实现</h3><p>下面我们来思考一下如何实现 <code>connect</code>，我们先回顾一下 <code>connect</code> 的使用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure>
<p>我们知道，<code>connect</code> 接收 <code>mapStateToProps</code>、<code>mapDispatchToProps</code> 两个方法，然后返回一个高阶函数，这个高阶函数接收一个组件，返回一个高阶组件，其实目的就是给传入组件增加一些属性和功能，connect 根据传入的 <code>mapStateToProps</code>、<code>mapDispatchToProps</code>，将 state 和 dispatch(action) 挂载到子组件的 props 上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                <span class="comment">// 从 context 获取 store 并订阅更新</span></span><br><span class="line">                <span class="keyword">this</span>.context.store.subscribe(<span class="keyword">this</span>.handleStoreChange.bind(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            handleStoreChange() &#123;</span><br><span class="line">                <span class="comment">// 触发更新</span></span><br><span class="line">                <span class="comment">// 触发的方法有多种，这里为了简洁起见，直接 forceUpdate 强制更新，读者也可以通过 setState 来触发子组件更新</span></span><br><span class="line">                <span class="keyword">this</span>.forceUpdate()</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;Component</span><br><span class="line">                        <span class="comment">// 传入该组件的 props，需要由 connect 这个高阶组件原样传回原组件</span></span><br><span class="line">                        &#123; ...this.props &#125;</span><br><span class="line">                        <span class="comment">// 根据 mapStateToProps 把 state 挂到 this.props 上</span></span><br><span class="line">                        &#123; ...mapStateToProps(<span class="keyword">this</span>.context.store.getState()) &#125;</span><br><span class="line">                        <span class="comment">// 根据 mapDispatchToProps 把 dispatch(action) 挂到 this.props 上</span></span><br><span class="line">                        &#123; ...mapDispatchToProps(<span class="keyword">this</span>.context.store.dispatch) &#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收 context 的固定写法</span></span><br><span class="line">        Connect.contextTypes = &#123;</span><br><span class="line">            store: PropTypes.object</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Connect</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="redux-Middleware"><a href="#redux-Middleware" class="headerlink" title="redux Middleware"></a>redux Middleware</h2><p>所谓中间件，我们可以理解为拦截器，用于对某些过程进行拦截和处理，且中间件之间能够串联使用。在 redux 中，我们中间件拦截的是 dispatch 提交到 reducer 这个过程，从而增强 dispatch 的功能。</p>
<p>可查阅<a href="https://redux.js.org/advanced/middleware/" target="_blank" rel="noopener">官方文档</a>。</p>
<p>接下来让我们和官方文档一样，以一个记录日志的中间件为例，一步一步分析 redux 中间件的设计实现。</p>
<h3 id="在每次-dispatch-之后手动打印-store-的内容"><a href="#在每次-dispatch-之后手动打印-store-的内容" class="headerlink" title="在每次 dispatch 之后手动打印 store 的内容"></a>在每次 dispatch 之后手动打印 store 的内容</h3><p>假如我们想在每次 dispatch 之后，打印一下 store 的内容，我们则会这样去实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'plus'</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure>
<p>这是最简单直接的实现方式，当然我们并不可能在项目每个 dispatch 的地方都添加这样一段代码，我们可以把这部分功能的代码提取出来。</p>
<h3 id="封装-dispatch"><a href="#封装-dispatch" class="headerlink" title="封装 dispatch"></a>封装 dispatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreToAddLogging</span>(<span class="params">store, action</span>) </span>&#123;</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以减少一部分重复的代码。不过每次使用这个新的 dispatch 都得从外部引一下，依然没有解决增加不必要的业务代码。</p>
<p>所以我们得思考另外一种一劳永逸的方式，替换 dispatch：</p>
<h3 id="替换-dispatch"><a href="#替换-dispatch" class="headerlink" title="替换 dispatch"></a>替换 dispatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">patchStoreToAddLogging</span>(<span class="params">action</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> result = next(action)  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())  </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们每次使用的时候就不需要再从外部引用一次了。</p>
<p>但这样还是不够好的，试想一下，如果我们又有其他的需求，比方监控 dispatch 错误，我们固然可以在打印日志的代码后面加上捕获错误的代码，但随着功能模块的增多，代码量也会迅速膨胀，导致难以维护。</p>
<p>所以，我们希望不同的功能是独立的可拔插的模块。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印 state 中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreToAddLogging</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = store.dispatch    <span class="comment">//此处也可以写成匿名函数</span></span><br><span class="line">    store.dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = next(action)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 监控错误中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreToAddCrashReporting</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里取到的 dispatch 已经是被上一个中间件包装过的 dispatch，从而实现中间件串联</span></span><br><span class="line">    <span class="keyword">const</span> next = store.dispatch</span><br><span class="line">    store.dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next(action)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'捕获一个异常!'</span>, err)</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">patchStoreToAddLogging(store)</span><br><span class="line">patchStoreToAddCrashReporting(store)</span><br></pre></td></tr></table></figure>
<p>到这里我们基本实现了可组合、拔插的中间件。</p>
<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>我们注意到，我们当前写的中间件方法都是先获取 dispatch，然后在方法内替换 dispatch，这部分重复代码我们可以再稍微简化一下。</p>
<p>我们不在方法内替换 dispatch，而是返回一个新的 dispatch，然后让循环来进行每一步的替换：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = store.dispatch</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = next(action)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crashReporter</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = store.dispatch</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next(action)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'捕获一个异常!'</span>, err)</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middlewares</span>) </span>&#123;</span><br><span class="line">    middlewares = middlewares.slice()   <span class="comment">// 返回新数组，避免 reserve() 影响原数组</span></span><br><span class="line">    middlewares.reverse()               <span class="comment">// 由于循环替换 dispatch 时，前面的中间件在最里层，因此需要翻转数组才能保证中间件的调用顺序</span></span><br><span class="line">    <span class="comment">// 循环替换 dispatch</span></span><br><span class="line">    middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span> (store.dispatch = middleware(store)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyMiddleware(store, [ logger, crashReporter ])</span><br></pre></td></tr></table></figure>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>之前的例子已经基本实现我们的需求，但我们还可以进一步改进，上面这个函数看起来仍然不够”纯“，函数在函数体内修改了 store 自身的 dispatch ，产生了所谓的“副作用”，从函数式编程的规范出发，我们可以进行一些改造，借鉴 react-redux 的实现思路，我们可以把 applyMiddleware 作为高阶函数，用于增强 store，而不是替换 dispatch。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reducer &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> crashReporter = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'捕获一个异常!'</span>, err)</span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span></span><br><span class="line">  <span class="keyword">typeof</span> action === <span class="string">'function'</span></span><br><span class="line">    ? action(store.dispatch, store.getState)</span><br><span class="line">    : next(action)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line">    <span class="keyword">let</span> &#123; getState, dispatch &#125; = store</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        getState,</span><br><span class="line">        <span class="comment">// 如果所有中间件都共享同一个 dispatch，出现中间件修改了 dispatch 或者进行异步 dispatch 就可能出错</span></span><br><span class="line">        dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middlewareArr = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(params))</span><br><span class="line">    dispatch = compose(...middlewareArr)(dispatch)</span><br><span class="line">    <span class="keyword">return</span> &#123; ...store, dispatch &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compose 这一步对应了 middlewares.reverse()，是函数式编程一种常见的组合方法</span></span><br><span class="line"><span class="comment">// 使传入的中间件函数变成 (...arg) =&gt; mid1(mid2(mid3(...arg)))</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span><span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(applyMiddleware) &#123;</span><br><span class="line">       <span class="keyword">return</span> enhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> observers = []          <span class="comment">// 观察者队列</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">       currentState = reducer(currentState, action)</span><br><span class="line">       observers.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'@STATE_INIT@'</span>&#125;); <span class="comment">// 初始化 state 数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        observers.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; getState, subscribe, dispatch &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createStore(reducer, applyMiddleware(logger, crashReporter, thunk))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承的几种方式</title>
    <url>/2020/04/07/javascript-extend/</url>
    <content><![CDATA[<p>在了解继承之前，我们先了解构造函数、原型和原型链的相关知识。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数和普通函数的区别仅在于调用它们的方式不同。只要通过 <code>new</code> 操作符来调用，那它就可以作为构造函数；如果不通过 <code>new</code> 操作符来调用，那么它就是一个普通函数。</p>
<p>实例拥有 <code>constructor</code> 属性，该属性返回创建实例对象的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'XYue'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>我们创建的每个函数都有 <code>prototype</code> 属性，这个属性指向函数的原型对象。原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> 属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象（可以通过实例的 <code>__proto__</code> 来访问构造函数的原型对象）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'XYue'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'歆月'</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// XYue</span></span><br><span class="line">person2.sayName(); <span class="comment">// 歆月</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个可以指向原型对象的内部指针（可以通过 <code>__proto__</code> 访问）。</p>
<p>假如我们让原型对象等于另一个类型的实例，那么此时原型对象包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，就构成了实例与原型的链条，这就是原型链的基本概念。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hobbies = [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getHobbies = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.hobbies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubType();</span><br><span class="line">sub1.hobbies.push(<span class="string">'篮球'</span>);</span><br><span class="line">sub1.getHobbies(); <span class="comment">// ['唱', '跳', 'rap', '篮球']</span></span><br><span class="line">sub2.getHobbies(); <span class="comment">// ['唱', '跳', 'rap', '篮球']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>缺点<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数</li>
</ol>
</li>
</ul>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>基本思路：在子类型的构造函数中调用超类型构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hobbies = [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getHobbies = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.hobbies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType(<span class="string">'XYue-1'</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubType(<span class="string">'XYue-2'</span>);</span><br><span class="line">sub1.hobbies.push(<span class="string">'篮球'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.hobbies); <span class="comment">// ['唱', '跳', 'rap', '篮球'];</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.hobbies); <span class="comment">// ['唱', '跳', 'rap'];</span></span><br><span class="line">sub1.getHobbies(); <span class="comment">// Uncaught TypeError: sub1.getHobbies is not a function</span></span><br></pre></td></tr></table></figure>
<ul>
<li>优点<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
</li>
<li>缺点<ol>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ol>
</li>
</ul>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。</p>
<p>基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hobbies = [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getHobbies = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.hobbies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType(<span class="string">'XYue1'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubType(<span class="string">'XYue2'</span>, <span class="number">20</span>);</span><br><span class="line">sub1.hobbies.push(<span class="string">'篮球'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.hobbies); <span class="comment">// ['唱', '跳', 'rap', '篮球'];</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.hobbies); <span class="comment">// ['唱', '跳', 'rap'];</span></span><br><span class="line">sub1.getHobbies(); <span class="comment">// ['唱', '跳', 'rap', '篮球'];</span></span><br><span class="line">sub1.getAge(); <span class="comment">// 18</span></span><br><span class="line">sub2.getAge(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>优点<ol>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ol>
</li>
<li>缺点<ol>
<li>无论什么情况下，都会调用两次超类型构造函数。一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</li>
</ol>
</li>
</ul>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>object()</code> 函数内部，先添加一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，<code>object()</code> 对传入的对象执行了一次浅拷贝。<br><code>ECMAScript5</code> 通过新增 <code>Object.create()</code> 方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象（可以覆盖原型对象上的同名属性），在传入一个参数的情况下，<code>Object.create()</code> 和 <code>object()</code> 方法的行为相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'XYue'</span>,</span><br><span class="line">    hobbies: [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.hobbies.push(<span class="string">'🏀'</span>);</span><br><span class="line">person2.hobbies.push(<span class="string">'⚽️'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.hobbies); <span class="comment">// ["唱", "跳", "rap", "🏀", "⚽️"]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hobbies); <span class="comment">// ["唱", "跳", "rap", "🏀", "⚽️"]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hobbies); <span class="comment">// ["唱", "跳", "rap", "🏀", "⚽️"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>缺点<ol>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享</li>
</ol>
</li>
</ul>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p><code>寄生继承</code> 是依托于一个对象而生的一种继承方式，因此称之为 <code>寄生</code>。</p>
<p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    clone.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大山的子孙呦~爱太阳啰~'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'XYue'</span>,</span><br><span class="line">    hobbies: [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line">person1.sing(); <span class="comment">// 大山的子孙呦~爱太阳啰~</span></span><br></pre></td></tr></table></figure>
<ul>
<li>缺点<ol>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享</li>
</ol>
</li>
</ul>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链继承的形式来继承方法。</p>
<p>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建超类型原型的一个副本</span></span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype);</span><br><span class="line">    <span class="comment">// 为创建的副本添加 constructor 属性</span></span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    <span class="comment">// 将新创建的对象赋值给子类型的原型</span></span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们就可以通过调用 <code>inheritPrototype</code> 为子类型原型赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hobbies = [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br></pre></td></tr></table></figure>
<ul>
<li>优点<ol>
<li>只调用了一次超类构造函数，效率更高</li>
<li>避免在 <code>SubType.prototype</code> 上面创建不必要的、多余的属性，与其同时，原型链还能保持不变</li>
</ol>
</li>
</ul>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h3 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h3><p><code>Class</code> 可以通过 extends 关键字实现继承，如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hobbies = [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub = <span class="keyword">new</span> SubType(<span class="string">'XYue'</span>, <span class="number">20</span>);</span><br><span class="line">sub.getName(); <span class="comment">// XYue</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>extends</code> 关键字实现继承，有一点需要特别说明：</p>
<p>子类必须在 <code>constructor</code> 中调用 <code>super</code> 方法，否则新建实例时会报错。如果没有子类没有定义 <code>constructor</code> 方法，那么这个方法会被默认添加。在子类的构造函数中，只有调用 <code>super</code> 之后，才能使用 <code>this</code> 关键字，否则报错。这是因为子类实例的构建，基于父类实例，只有 <code>super</code> 方法才能调用父类实例。</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 实现原理</title>
    <url>/2020/03/30/promise-realize/</url>
    <content><![CDATA[<h2 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h2><p>在 <code>javascript</code> 的世界中，代码都是 <code>单线程</code> 执行的。这就导致我们的代码里会有嵌套回调函数，一旦嵌套过多，导致代码不容易理解和维护。为了降低异步编程的复杂性，开发人员一直在寻找各种解决方案，<code>Promise</code> 就是用来处理异步操作的其中一个方案。</p>
<p>下面将根据 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 的规范，来写出符合规范的源码。</p>
<h2 id="Promise-的基本使用"><a href="#Promise-的基本使用" class="headerlink" title="Promise 的基本使用"></a>Promise 的基本使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>); <span class="comment">// 这里如果是 reject('fail')</span></span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 输出：success</span></span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 上面如果执行 reject('fail')，这里就输出 fail</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>resolve 找 then 里的成功回调，reject 找 then 里失败的回调。</p>
<p>接下来我们将按自己的方式一步步实现这样的一个 Promise 类，直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = []; <span class="comment">// 成功回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejected = []; <span class="comment">// 失败回调队列</span></span><br><span class="line">    <span class="comment">// PromiseA+ 2.1</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.onFulfilled.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn()); <span class="comment">// PromiseA+ 2.2.6.1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">        <span class="keyword">this</span>.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn()); <span class="comment">// PromiseA+ 2.2.6.1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onFulfilled.push(<span class="function"><span class="params">()</span> =&gt;</span> onFulfilled(<span class="keyword">this</span>.value));</span><br><span class="line">      <span class="keyword">this</span>.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> onRejected(<span class="keyword">this</span>.reason));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>
<p>这样我们就简单的实现了一个 Promise 应该拥有的基本功能。</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>在上述代码中我们并没有处理 then 的链式调用，直接使用则会报错：TypeError: Cannot read property ‘then’ of undefined。</p>
<p>在 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 规范中提到：</p>
<blockquote>
<p>2.2.6 <code>then</code> may be called multiple times on the same promise.<br>2.2.6.1 If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks must execute in the order of their originating calls to <code>then</code>.<br>2.2.6.2 If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks must execute in the order of their originating calls to <code>then</code>.<br>2.2.7 <code>then</code> must return a promise [3.3].<br>2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>\[\[Resolve]](promise2, x)</code>.<br>2.2.7.2 If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with e as the reason.<br>2.2.7.3 If <code>onFulfilled</code> is not a function and <code>promise1</code> is fulfilled, <code>promise2</code> must be fulfilled with the same value as <code>promise1</code>.<br>2.2.7.4 If <code>onRejected</code> is not a function and <code>promise1</code> is rejected, <code>promise2</code> must be rejected with the same reason as <code>promise1</code>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.2.6 then 方法可能被多次调用</span><br><span class="line">2.2.6.1 如果 promise 变成了 fulfilled 态，所有的 onFulfilled 回调都需要按照 then 的顺序执行</span><br><span class="line">2.2.6.2 如果 promise 变成了 rejected 态，所有的 onRejected 回调都需要按照 then 的顺序执行</span><br><span class="line"></span><br><span class="line">2.2.7 then 必须返回一个 promise</span><br><span class="line">2.2.7.1 如果 onFulfilled 或 onRejected 执行的结果为 x，调用 handlePromise</span><br><span class="line">2.2.7.2 如果 onFulfilled 或者 onRejected 执行时抛出异常 e，promise2 需要被 reject</span><br><span class="line">2.2.7.3 如果 onFulfilled 不是一个函数，promise2 以 promise1 的 value fulfilled</span><br><span class="line">2.2.7.4 如果 onRejected 不是一个函数，promise2 以 promise1 的 reason rejected</span><br></pre></td></tr></table></figure>
<p>所以 then 方法里可能返回一个值或者返回的一个 Promise 实例，我们需要分别处理这两种情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 省略如上</span></span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// PromiseA+ 2.2.1 / PromiseA+ 2.2.5 / PromiseA+ 2.2.7.3 / PromiseA+ 2.2.7.4</span></span><br><span class="line">    <span class="comment">// 值穿透 promise.then().then().then(res =&gt; &#123; console.log(res); &#125;)</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">"function"</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason; &#125;;</span><br><span class="line">    <span class="comment">// PromiseA+ 2.2.7 返回一个新的 Promise</span></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">// PromiseA+ 2.2.2</span></span><br><span class="line">        <span class="comment">// PromiseA+ 2.2.4 --- setTimeout 模拟异步任务（规范要求）</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// PromiseA+ 2.2.7.1</span></span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            handlePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// PromiseA+ 2.2.7.2</span></span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">        <span class="comment">// PromiseA+ 2.2.3</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            handlePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onFulfilled.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">              handlePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.onRejected.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">              handlePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// PromiseA+ 2.3.1 promise2 是否等于x，判断是否将自己本身返回，抛出 TypeError 错误</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// PromiseA+ 2.3.3</span></span><br><span class="line">  <span class="keyword">if</span> (x &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> used; <span class="comment">// PromiseA+ 2.3.3.3.3 控制 resolve 或 reject 只执行一次（规范要求）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// PromiseA+ 2.3.3.1</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// 如果是函数，就认为它是返回新的 promise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// PromiseA+ 2.3.3.1</span></span><br><span class="line">        then.call(x, (y) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (used) <span class="keyword">return</span>;</span><br><span class="line">          used = <span class="literal">true</span>;</span><br><span class="line">          handlePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, (r) =&gt; &#123;</span><br><span class="line">          <span class="comment">// PromiseA+ 2.3.3.2</span></span><br><span class="line">          <span class="keyword">if</span> (used) <span class="keyword">return</span>;</span><br><span class="line">          used = <span class="literal">true</span>;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// PromiseA+ 2.3.3.4 x 是普通值，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (used) <span class="keyword">return</span>;</span><br><span class="line">        used = <span class="literal">true</span>;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// PromiseA+ 2.3.3.2</span></span><br><span class="line">      <span class="keyword">if</span> (used) <span class="keyword">return</span>;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// PromiseA+ 2.3.4 x 是普通值，直接返回</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>
<p>这样我们就实现一个完全符合 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 规范的 <code>Promise</code> 了。</p>
<p>让我们安装测试脚本检测下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g promises-aplus-tests</span><br></pre></td></tr></table></figure>
<p>在 Promise 实现的代码中添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应目录下执行以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure>
<p>promises-aplus-tests 中共有 872 条测试用例，以上代码，可以完美通过所有用例。</p>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><ol>
<li>new Promise 时，需要传递一个 executor 执行器，执行器立刻执行</li>
<li>executor 接受两个参数，分别是 resolve 和 reject</li>
<li>promise 只能从 pending 到 rejected, 或者从 pending 到 fulfilled</li>
<li>promise 的状态一旦确认，就不会再改变</li>
<li>promise 都有 then 方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled,和 promise 失败的回调 onRejected</li>
<li>如果调用 then 时，promise 已经成功，则执行 onFulfilled，并将 promise 的值作为参数传递进去；<br>如果 promise 已经失败，那么执行 onRejected, 并将 promise 失败的原因作为参数传递进去；<br>如果 promise 的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行（发布订阅）</li>
<li>then 的参数 onFulfilled 和 onRejected 可以缺省</li>
<li>promise 可以 then 多次，promise 的 then 方法返回一个 promise</li>
<li>如果 then 返回的是一个结果，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调(onFulfilled)</li>
<li>如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调(onRejected)</li>
<li>如果 then 返回的是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功，如果失败，就走下一个 then 的失败</li>
</ol>
<h2 id="Promise-其他方法"><a href="#Promise-其他方法" class="headerlink" title="Promise 其他方法"></a>Promise 其他方法</h2><p>虽然我们已经实现了一个 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 规范的 Promise，但是相比原生的 Promise 还缺少一些方法:</p>
<ul>
<li>Promise.prototype.catch()</li>
<li>Promise.prototype.finally()</li>
<li>Promise.resolve()</li>
<li>Promise.reject()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<p>下面，我们将逐一实现：</p>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><p>用于指定出错时的回调，是特殊的 then 方法，catch 之后，可以继续 then。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p>不管成功还是失败，都会走到 finally 中，并且 finally 之后，还可以继续 then。并且将值原封不动的传递给后面的 then。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promise.resolve(value) 返回一个以给定值解析后的 promise 对象.</p>
<ol>
<li>如果 value 是个 thenable 对象，返回的 promise 会跟随这个 thenable 的对象，采用它的最终状态</li>
<li>如果传入的 value 本身就是 promise 对象，那么 Promise.resolve 将不做任何修改、原封不动地返回这个 promise 对象</li>
<li>其他情况，直接返回以该值为成功状态的 promise 对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (param &amp;&amp; param.then &amp;&amp; <span class="keyword">typeof</span> param.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 为保持与原生 Promise 对象执行顺序一致，模拟使用 setTimeout</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        param.then(resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(param);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>Promise.reject 方法和 Promise.resolve 不同，Promise.reject() 方法的参数会原封不动地作为 reject 的理由，变成后续方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all(promises) 返回一个 promise 对象。</p>
<ol>
<li>如果传入的参数是一个空的可迭代对象，那么此 promise 对象回调完成 resolve，只有此情况，是同步执行的，其它都是异步返回的</li>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成</li>
<li>等待 promises 中所有的 promise 执行完毕</li>
<li>如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败</li>
<li>在任何情况下，Promise.all 返回的 promise 完成状态的结果都是一个数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processValue</span>(<span class="params">i, data</span>) </span>&#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//promises[i] 可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          processValue(i, data);</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>不同于 <code>Promise.all</code>，一旦有一个 <code>promise</code> 执行失败，就无法获得其他成功 <code>promise</code> 返回。<code>Promise.allSettled</code> 方法下无论某个 <code>promise</code> 成功与否，所有的 <code>promise</code> 总是被 <code>resolve</code> 的，并且值是所有 <code>promise</code> 执行结果的描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processValue</span>(<span class="params">i, data</span>) </span>&#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//promises[i] 可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          processValue(i, &#123; <span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: data &#125;);</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          processValue(i, &#123; <span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>顾名思义，Promse.race 就是赛跑的意思。意思就是说，Promise.race([p1, p2, p3]) 里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p>
<ol>
<li>如果传的参数数组是空，则返回的 promise 将永远等待</li>
<li>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细代码，同步 <a href="https://github.com/fuzhongyi/Promise" target="_blank" rel="noopener">github</a></p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>从多线程到 Event Loop</title>
    <url>/2020/03/21/event-loop/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/header-img.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>在我们的认知中，javascript 是单线程的，但它又是如何完成诸如异步请求这种多线程操作的呢？<br>我们先从进程、线程的角度来了解这个问题。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li><code>进程</code> 是 <code>cpu</code> 资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li><code>线程</code> 是 <code>cpu</code> 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>不同进程之间也可以通信，代价较大</li>
</ul>
<p>简单理解，我们把 <code>cpu</code> 比作工厂，工厂有多个车间，但工厂的电力有限，每次只能供给一个车间使用（单个 <code>cpu</code> 一次只能运行一个任务）。<code>进程</code> 就好比工厂的车间，它代表 <code>cpu</code> 所能处理的单个任务, 进程之间相互独立，任一时刻，<code>cpu</code> 总是运行一个进程，其他进程处于非运行状态。 <code>cpu</code> 使用时间片轮转进度算法来实现同时运行多个进程。<code>线程</code> 就好比车间里的工人，一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。</p>
<p>一个 <code>进程</code> 可以包括多个 <code>线程</code>，多个 <code>线程</code> 共享 <code>进程</code> 资源。</p>
<h2 id="浏览器包含了哪些进程"><a href="#浏览器包含了哪些进程" class="headerlink" title="浏览器包含了哪些进程"></a>浏览器包含了哪些进程</h2><ul>
<li><p>主进程</p>
<ul>
<li>协调控制其他子进程（创建、销毁）</li>
<li>浏览器界面显示，用户交互，前进、后退、收藏</li>
<li>将渲染进程得到的内存中的 Bitmap，绘制到用户界面上</li>
<li>处理不可见操作，网络请求，文件访问等</li>
</ul>
</li>
<li><p>第三方插件进程</p>
<ul>
<li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
</ul>
</li>
<li><p>GPU进程</p>
<ul>
<li>用于3D绘制等</li>
</ul>
</li>
<li><p>渲染进程，就是我们说的浏览器内核</p>
<ul>
<li>负责页面渲染，脚本执行，事件处理等</li>
<li>每个tab页一个渲染进程</li>
</ul>
</li>
</ul>
<p>了解到浏览器所包含的进程，我们可以发现，渲染进程是前端操作最重要的一环。</p>
<h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><p>我们知道，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。</p>
<p>对于 <code>渲染进程</code> 而言，它也是多线程的，包含：</p>
<ul>
<li><p>GUI 渲染线程</p>
<ul>
<li>负责渲染页面，布局和绘制</li>
<li>页面需要重绘和回流时，该线程就会执行</li>
<li>与 JS 引擎线程互斥，防止渲染结果不可预期</li>
</ul>
</li>
<li><p>JS 引擎线程</p>
<ul>
<li>负责处理解析和执行 javascript 脚本程序</li>
<li>只有一个 JS 引擎线程（单线程）</li>
<li>与 GUI 渲染线程互斥，防止渲染结果不可预期</li>
</ul>
</li>
<li><p>事件触发线程</p>
<ul>
<li>用来控制事件循环（鼠标点击、setTimeout、ajax 等）</li>
<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>
</ul>
</li>
<li><p>定时触发器线程</p>
<ul>
<li>setInterval 与 setTimeout 所在的线程</li>
<li>定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的</li>
<li>计时完毕后，通知事件触发线程</li>
</ul>
</li>
<li><p>异步 http 请求线程</p>
<ul>
<li>浏览器有一个单独的线程用于处理 ajax 请求</li>
<li>当请求完成时，若有回调函数，通知事件触发线程</li>
</ul>
</li>
</ul>
<p>当我们了解了渲染进程包含的线程后，我们思考为什么 javascript 是单线程的。</p>
<h2 id="为什么是单线程"><a href="#为什么是单线程" class="headerlink" title="为什么是单线程"></a>为什么是单线程</h2><p>因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>
<h2 id="从-event-loop-看-JS-运行机制"><a href="#从-event-loop-看-JS-运行机制" class="headerlink" title="从 event loop 看 JS 运行机制"></a>从 event loop 看 JS 运行机制</h2><p>到了这里，终于要进入我们的主题，什么是 <code>event loop</code>。</p>
<p>先理解一些概念：</p>
<ul>
<li>JS 分为同步任务和异步任务</li>
<li>同步任务都在 JS 引擎线程上执行，形成一个执行栈</li>
<li>事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放到任务队列中</li>
<li>执行栈中所有同步任务执行完毕，此时 JS 引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/5-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>在前端开发中我们会通过 <code>setTimeout</code>、<code>setInterval</code> 来指定定时任务，通过 <code>xhr</code>、<code>fetch</code> 发送网络请求。</p>
<p>我们知道，不管是这些定时任务或者网络请求，这些代码在执行，本身是同步任务的，而其中的回调函数才是异步任务。</p>
<p>当代码执行到 <code>setTimeout</code>、<code>setInterval</code> 时，实际上是 <code>JS引擎线程</code> 通知 <code>定时触发器线程</code>，在间隔指定时间后，会触发一个回调事件， 而 <code>定时触发器线程</code> 在接收到这个消息后，会在等待的时间后，将回调事件放入到由 <code>事件触发线程</code> 所管理的事件队列中。</p>
<p>当代码执行到 <code>xhr</code>、<code>fetch</code> 时，实际上是 <code>JS引擎线程</code> 通知 <code>异步http请求线程</code>，发送一个网络请求，并制定请求完成后的回调事件， 而 <code>异步http请求线程</code> 在接收到这个消息后，会在请求成功后，将回调事件放入到由<code>事件触发线程</code> 所管理的事件队列中。</p>
<p>当我们的同步任务执行完，<code>JS引擎线程</code> 会询问 <code>事件触发线程</code>，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给 <code>JS引擎线程</code> 执行。</p>
<p>用一张图来解释：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/5-2.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>总结：</p>
<ol>
<li>JS 引擎线程执行执行栈中的事件</li>
<li>执行栈中的事件执行完毕，就开始读取事件队列中的事件</li>
<li>事件队列中的回调事件加入到执行栈依次执行</li>
</ol>
<p><code>2</code>,<code>3</code> 重复循环</p>
<h2 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h2><p>当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中 <code>宏任务</code>、<code>微任务</code>。</p>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），<br>每一个宏任务会从头到尾执行完毕，不会执行其他。<br>我们前文提到过 <code>JS引擎线程</code> 和 <code>GUI渲染线程</code> 是互斥的关系，浏览器为了能够使宏任务和 <code>DOM</code> 任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，<code>GUI 渲染线程</code> 开始工作，对页面进行渲染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏任务--&gt;渲染--&gt;宏任务--&gt;渲染--&gt;．．．</span></span><br></pre></td></tr></table></figure>
<p><code>script（主代码块）</code>，<code>setTimeout</code>，<code>setInterval</code>、<code>I/O(ajax)</code>,<code>setImmedidate(node)</code>，都属于宏任务。</p>
<p>举个例子🌰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:black'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:red'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:grey'</span>;</span><br></pre></td></tr></table></figure>
<p>我们将这段代码放到浏览器控制台执行一下，看一下效果：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/6-1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我们看到，页面背景会在瞬间变成灰色。这是因为以上代码属于同一次宏任务，所以全部执行完才触发页面渲染，渲染时<code>GUI 渲染线程</code>会将所有 UI 改动合并优化，所以在视觉效果上，只会看到页面变成灰色。</p>
<p>再来个例子🌰🌰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style = <span class="string">'background:black'</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>执行一下，看下效果：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/6-2.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我们看到，页面先显示成蓝色背景，然后又变成了黑色背景，这是因为以上代码属于两次 <code>宏任务</code>，第一次 <code>宏任务</code> 执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次 <code>宏任务</code> 将背景变成黑色。</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>我们已经知道 <code>宏任务</code> 结束后，会执行渲染，然后执行下一个 <code>宏任务</code>， 而 <code>微任务</code> 可以理解成在当前 <code>宏任务</code> 执行后立即执行的任务。</p>
<p>也就是说，当 <code>宏任务</code> 执行完，会在渲染前，将执行期间所产生的所有 <code>微任务</code> 都执行完。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏任务--&gt;微任务--&gt;渲染--&gt;宏任务--&gt;微任务--&gt;渲染--&gt;．．．</span></span><br></pre></td></tr></table></figure>
<p><code>process.nextTick(node)</code>，<code>Promise</code>，<code>MutationObserver</code> 属于微任务。</p>
<p><code>process.nextTick</code> 是有一个插队操作的，就是说他进入微任务队列时，会插到除了 <code>process.nextTick</code> 其他的微任务前面。</p>
<p>举个例子🌰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.style = <span class="string">'background:black'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>执行一下，看下效果：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/6-3.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>控制台输出 1 3 2 , 是因为 <code>promise</code> 对象的 <code>then</code> 方法的回调函数是异步执行，所以 2 最后输出页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务，在微任务中将背景变成了黑色，然后才执行的渲染。</p>
<p>再比如说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 1 3 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码共包含两个 <code>setTimeout</code>，也就是说除主代码块外，还有两个 <code>宏任务</code>，其中第一个 <code>宏任务</code> 执行中，输出 1，并且创建了 <code>微任务队列</code>，所以在下一个 <code>宏任务队列</code> 执行前，先执行 <code>微任务</code>，在 <code>微任务</code> 执行中，输出 3 ，<code>微任务</code> 执行后，执行下一次 <code>宏任务</code>，执行中输出 2。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>执行一个<code>宏任务</code> （栈中没有就从 <code>事件队列</code> 中获取）</li>
<li>执行过程中如果遇到 <code>微任务</code>，就将它添加到 <code>微任务队列</code>中</li>
<li>宏任务执行完毕后，立即执行当前 <code>微任务队列</code> 中的所有 <code>微任务</code> （依次执行）</li>
<li>当前 <code>宏任务</code> 执行完毕，开始检查渲染，然后 <code>GUI 渲染线程</code> 接管渲染</li>
<li>渲染完毕后，<code>JS引擎线程</code> 继续接管，开始下一个 <code>宏任务</code>（从事件队列中获取）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/21/event-loop/7-1.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="number">3</span>), <span class="number">2</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="number">2</span>), <span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>没有深入接触过 <code>timer</code> 的同学如果直接从代码中的延时设置来看，会回答：<code>1、2、3</code>。</p>
<p>而另一些有一定经验的同学可能会回答：<code>3、2、1</code>。因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">MDN 的 setTimeout</a> 文档中提到 <code>HTML</code> 规范最低延时为 <strong>4ms</strong>：</p>
<p><em>(补充说明：最低延时的设置是为了给CPU留下休息时间）</em></p>
<blockquote>
<p>In fact, 4ms is specified by the HTML5 spec and is consistent across browsers released in 2010 and onward. Prior to (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2), the minimum timeout value for nested timeouts was 10 ms.</p>
</blockquote>
<p>而真正痛过的同学会告诉你，答案是：<code>1、0、2</code>。</p>
<p>我们发现 0ms 和 1ms 的延时效果是一样的，通过资料我们发现：</p>
<h3 id="在-chrome-中"><a href="#在-chrome-中" class="headerlink" title="在 chrome 中"></a>在 chrome 中</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp#93</span></span><br><span class="line">double intervalMilliseconds = std::max(oneMillisecond, interval * oneMillisecond);</span><br></pre></td></tr></table></figure>
<p>这里 interval 就是传入的数值，可以看出传入 0 和传入 1 结果都是 oneMillisecond，即 1ms。</p>
<p>这样解释了为何 1ms 和 0ms 行为是一致的，那 4ms 到底是怎么回事？查阅 <a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers" target="_blank" rel="noopener">HTML 规范</a>，发现虽然有 4ms 的限制，但是是存在条件的，详见规范第 11 点：</p>
<blockquote>
<p>If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.</p>
</blockquote>
<h3 id="在-node-中"><a href="#在-node-中" class="headerlink" title="在 node 中"></a>在 node 中</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/v8.9.4/lib/timers.js#L456</span></span><br><span class="line"><span class="keyword">if</span> (!(after &gt;= <span class="number">1</span> &amp;&amp; after &lt;= TIMEOUT_MAX))</span><br><span class="line">  after = <span class="number">1</span>; <span class="comment">// schedule on next tick, follows browser behavior</span></span><br></pre></td></tr></table></figure>
<p>代码中的注释直接说明了，设置最低 1ms 的行为是为了向浏览器行为看齐。</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>this、call、apply、bind</title>
    <url>/2020/03/18/this-call-apply-bind/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2020/03/18/this-call-apply-bind/header-img.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>面向对象语言中 <code>this</code> 表示当前对象的一个引用。<br>但在 <code>JavaScript</code> 中 <code>this</code> 不是固定不变的，它会随着执行环境的改变而改变。</p>
<h3 id="普通函数指向函数的调用者"><a href="#普通函数指向函数的调用者" class="headerlink" title="普通函数指向函数的调用者"></a>普通函数指向函数的调用者</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'xyue'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// xyue</span></span><br></pre></td></tr></table></figure>
<p><code>foo()</code> 直接调用，非严格模式下 <code>this</code> 指向 <code>window</code> ，严格模式下 <code>this</code> 指向 <code>undefined</code>;</p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'xyue1'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'xyue2'</span>,</span><br><span class="line">    foo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(); <span class="comment">// xyue2</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; </span><br><span class="line">bar(); <span class="comment">// xyue1</span></span><br></pre></td></tr></table></figure>
<p><code>obj.foo()</code> 是 <code>obj</code> 通过 <code>.</code> 运算符调用了 <code>foo()</code>，所以 <code>this</code> 指向  <code>obj</code>；<br><code>bar()</code> 实际上是把 <code>foo</code> 函数赋值给了 <code>bar</code>，没有调用者，所以使用的是默认绑定规则，这里的 <code>this</code> 指向 <code>window</code>。</p>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'xyue1'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'xyue2'</span>,</span><br><span class="line">    foo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; </span><br><span class="line">bar(); <span class="comment">// xyue1</span></span><br><span class="line">bar.call(obj) <span class="comment">// xyue2</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>call</code>、 <code>apply</code> 、 <code>bind</code> 可以显式修改 <code>this</code> 的指向。</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="string">'xyue'</span>);</span><br><span class="line">foo.name;  <span class="comment">// xyue</span></span><br></pre></td></tr></table></figure>
<p><a href="/2020/03/17/what-did-new-do/#实现">new 实现原理</a></p>
<h3 id="箭头函数指向函数所在的所用域"><a href="#箭头函数指向函数所在的所用域" class="headerlink" title="箭头函数指向函数所在的所用域"></a>箭头函数指向函数所在的所用域</h3><p>箭头函数中没有 <code>this</code> 绑定，在箭头函数中 <code>this</code> 始终指向函数所在的所用域。（<strong><em>箭头函数不能作为构造函数</em></strong>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'xyue'</span>,</span><br><span class="line">    getName1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    getName2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName1(); <span class="comment">// xyue</span></span><br><span class="line">obj.getName2(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="call、apply、bind-实现"><a href="#call、apply、bind-实现" class="headerlink" title="call、apply、bind 实现"></a>call、apply、bind 实现</h2><p>在 <code>javascript</code> 中，<code>call</code>、<code>apply</code>、<code>bind</code> 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 <code>this</code> 的指向。</p>
<ul>
<li><p>相同点</p>
<ul>
<li>均可以改变 <code>this</code> 指向，第一个参数为 <code>this</code>的指向对象</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>函数调用 <code>call</code>、<code>apply</code> 时，直接调用函数，而 <code>bind</code> 返回一个新的函数</li>
<li><code>call</code>、<code>bind</code> 接收序列参数，<code>apply</code> 接收参数数组</li>
</ul>
</li>
</ul>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>举个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>注意两点：</p>
<ol>
<li><code>call</code> 改变了 <code>this</code> 的指向，指向到 <code>foo</code></li>
<li><code>bar</code> 函数执行了</li>
</ol>
<p>那么我们该怎么实现这两个效果呢？</p>
<p>试想当调用 <code>call</code> 的时候，把 <code>foo</code> 对象改造成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这个时候 <code>this</code> 就指向了 <code>foo</code>。</p>
<p>所以我们实现的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span>(args.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 <code>ES6</code> 扩展运算符，解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> [context, ...args] = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply</code> 的实现跟 <code>call</code> 类似，差异在与参数的传递上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// args 第二个参数为数组</span></span><br><span class="line">    <span class="keyword">var</span> [context, args] = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote>
<p><code>bind()</code> 方法会创建一个新函数。当这个新函数被调用时，<code>bind()</code> 的第一个参数将作为它运行时的 <code>this</code>，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p>
</blockquote>
<p>可以看出 bind 的 2 个特点：</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样还存在一个问题，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hobby = <span class="string">'sing'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype.friend = <span class="string">'xyue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo1 = Bar.bind(foo, <span class="string">'fuzy'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> bindFoo1(<span class="string">'18'</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// fuzy</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.hobby); <span class="comment">// sing</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.friend); <span class="comment">// xyue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo2 = Bar.myBind(foo, <span class="string">'fuzy'</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> bindFoo2(<span class="string">'18'</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// fuzy</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.hobby); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.friend); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个绑定函数也能使用 <code>new</code> 操作符创建对象：这种行为就像把原函数当成构造器。提供的 <code>this</code> 值被忽略，同时调用时的参数被提供给模拟函数。</p>
</blockquote>
<p>我们看到，当 <code>bind</code> 返回的函数作为构造函数的时候，<code>bind</code> 时指定的 <code>this</code> 值会失效，但传入的参数依然生效。</p>
<p>所以我们可以通过修改返回的函数的原型来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;;</span><br><span class="line">    fBound.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。<br>这个时候，我们可以通过一个空函数来进行中转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;;</span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到这，顺便说一下 <code>Object.create</code>，该方法创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code>。<br>不考虑第二个参数，对其主要功能做简单实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    f.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到我们可以发现，这不就是创建一个空函数进行中转么，所以我们的实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;;</span><br><span class="line">    fBound.prototype = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这都是模拟实现，并不是完美的，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hobby = <span class="string">'sing'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype.friend = <span class="string">'xyue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo1 = Bar.bind(foo, <span class="string">'fuzy'</span>);</span><br><span class="line"><span class="keyword">var</span> bindFoo2 = Bar.myBind(foo, <span class="string">'fuzy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bindFoo1.prototype); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bindFoo2.prototype); <span class="comment">// Bar &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们看到原生的 <code>bind</code> 返回的函数是没有 <code>prototype</code> 属性的。<br>正如原生的 <code>bind</code> 方法的特性定义的那样。</p>
<blockquote>
<p><code>bind</code>方法所返回的函数并不包含 <code>prototype</code> 属性，并且将这些绑定的函数用作构造函数所创建的对象从原始的未绑定的构造函数中继承 <code>prototype</code></p>
</blockquote>
<p>所以我们用 <code>es6</code> 方法实现做一些补充：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params">...bindArgs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allArgs = args.concat(bindArgs);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Fn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> self(...allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, allArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> Fn.prototype;</span><br><span class="line">    <span class="keyword">return</span> Fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样与原生的 <code>bind</code> 表现就大致一样了。</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript new 原理</title>
    <url>/2020/03/17/what-did-new-do/</url>
    <content><![CDATA[<h2 id="new-的作用"><a href="#new-的作用" class="headerlink" title="new 的作用"></a>new 的作用</h2><p>我们先通过简单的例子来了解下 <code>new</code> 的作用吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'xyue'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Person &#123;name: "xyue"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// xyue</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// xyue</span></span><br></pre></td></tr></table></figure>
<p>从上边例子中我们可以得到结论：</p>
<ul>
<li>通过 <code>new</code> 构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数中的属性</li>
<li>通过 <code>new</code> 构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性，也就是说通过 <code>new</code> 操作符，实例与构造函数通过原型链连接了起来</li>
</ul>
<p>但是当前的构造函数 <code>Person</code> 并没有 <code>return</code> 任何值，如果我们让它返回值会发生什么事情呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'xyue'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Person &#123;name: "xyue"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// xyue</span></span><br></pre></td></tr></table></figure>
<p>虽然在构造函数中返回了 <code>1</code>，但是这个返回值（原始值）并没有任何用处，得到的结果完全一样。<br>所以通过这个例子，我们可以得出另外一个结论：</p>
<ul>
<li>构造函数如果返回原始值，那么这个返回值没有意义</li>
</ul>
<p>试完了返回原始值，我们再来试试返回对象会发生什么事情吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Person &#123;name: "xyue"&#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'xyue'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>通过这个例子我们可以发现，当构造函数返回值为对象时，内部的 <code>this</code> 虽然正常工作，但是这个返回值会被正常的返回出去。<br>通过这个例子，我们再次得到一个结论：</p>
<ul>
<li>构造函数如果返回值为对象，那么这个返回值会被正常使用</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>通过以上几个例子，我们大致了解了 <code>new</code> 操作符的几个作用。</p>
<blockquote>
<p><strong><code>new</code> 运算符</strong> 创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<code>new</code> 关键字会进行如下的操作：</p>
</blockquote>
<ol>
<li>创建一个空的简单 JavaScript 对象（即<code>{}</code>）</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象</li>
<li>将步骤 1 新创建的对象作为 <code>this</code> 的上下文</li>
<li>如果该函数没有返回对象，则返回 <code>this</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的新对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 第一个参数是构造函数</span></span><br><span class="line">    <span class="keyword">var</span> [<span class="keyword">constructor</span>, ...args] = [...arguments];</span><br><span class="line">    // 将新对象的的原型指向当前构造函数的原型</span><br><span class="line">    obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">    // 执行构造函数，将属性或方法添加到创建的空对象上</span><br><span class="line">    var result = <span class="keyword">constructor</span>.apply(obj, args);</span><br><span class="line">    // 如果没有返回其他对象，就返回 obj，否则返回其他对象</span><br><span class="line">    return typeof result === 'object' ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_new(Person,'xyue'); // Person &#123;name: <span class="string">"xyue"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>new</code> 操作符，我们可以创建原对象的一个实例对象，而这个实例对象继承了原对象的属性和方法，所以 <code>new</code> 存在的意义在于它实现了 <code>javascript</code> 中的继承，而不仅仅是实例化了一个对象。</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 代码书写规范</title>
    <url>/2018/08/28/css-code-writing-standard/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2018/08/28/css-code-writing-standard/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>在样式文件的第一行首个字符位置写上 @charset 规则，编码名用 “UTF-8”。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.xyue</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><p>样式书写一般有两种：</p>
<ul>
<li>展开格式 (Expanded)</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>紧凑格式 (Compact)</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.xyue</span> &#123;<span class="attribute">display</span>: block;<span class="attribute">width</span>: <span class="number">100px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>使用展开格式书写样式</p>
<h1 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h1><p>样式选择器，属性名，属性值关键字均使用小写字母书写，属性字符串允许使用大小写。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span> </span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Microsoft YaHei UI'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.XYUE</span> &#123;</span><br><span class="line">    <span class="attribute">DISPLAY</span>: BLOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><ol>
<li>尽量少用通用选择器 *</li>
<li>不使用 ID 选择器</li>
<li>不使用无具体语义定义的标签选择器</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.xyue</span> <span class="selector-tag">li</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.xyue</span> <span class="selector-tag">li</span> <span class="selector-tag">p</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line">*&#123;&#125;</span><br><span class="line"><span class="selector-id">#xyue</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.xyue</span> <span class="selector-tag">div</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码易读性"><a href="#代码易读性" class="headerlink" title="代码易读性"></a>代码易读性</h1><h2 id="每个属性声明末尾都要加分号"><a href="#每个属性声明末尾都要加分号" class="headerlink" title="每个属性声明末尾都要加分号"></a>每个属性声明末尾都要加分号</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span>&#123; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左括号与类名之间一个空格，冒号与属性值之间一个空格"><a href="#左括号与类名之间一个空格，冒号与属性值之间一个空格" class="headerlink" title="左括号与类名之间一个空格，冒号与属性值之间一个空格"></a>左括号与类名之间一个空格，冒号与属性值之间一个空格</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span>&#123; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逗号分隔的取值，逗号之后一个空格"><a href="#逗号分隔的取值，逗号之后一个空格" class="headerlink" title="逗号分隔的取值，逗号之后一个空格"></a>逗号分隔的取值，逗号之后一个空格</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>, <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>,<span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为单个css选择器或新申明开启新行"><a href="#为单个css选择器或新申明开启新行" class="headerlink" title="为单个css选择器或新申明开启新行"></a>为单个css选择器或新申明开启新行</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span>, </span><br><span class="line"><span class="selector-class">.xyue_logo</span>, </span><br><span class="line"><span class="selector-class">.xyue_hd</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span>,<span class="selector-class">.xyue_logo</span>,<span class="selector-class">.xyue_hd</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;<span class="selector-class">.nav</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="颜色值-rgb-rgba-hsl-hsla-rect-中不需有空格，且取值不要带有不必要的-0"><a href="#颜色值-rgb-rgba-hsl-hsla-rect-中不需有空格，且取值不要带有不必要的-0" class="headerlink" title="颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0"></a>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性值十六进制数值能用简写的尽量用简写"><a href="#属性值十六进制数值能用简写的尽量用简写" class="headerlink" title="属性值十六进制数值能用简写的尽量用简写"></a>属性值十六进制数值能用简写的尽量用简写</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不要为-0-指明单位"><a href="#不要为-0-指明单位" class="headerlink" title="不要为 0 指明单位"></a>不要为 0 指明单位</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="属性值引号"><a href="#属性值引号" class="headerlink" title="属性值引号"></a>属性值引号</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YES */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123; </span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Microsoft YaHei UI'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO */</span></span><br><span class="line"><span class="selector-class">.xyue</span> &#123; </span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei UI"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="属性书写顺序"><a href="#属性书写顺序" class="headerlink" title="属性书写顺序"></a>属性书写顺序</h1><p>遵循以下顺序：</p>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … </li>
</ol>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.xyue</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, <span class="string">'Helvetica Neue'</span>, Helvetica, sans-serif;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-ms-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-o-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong><em>CSS3 浏览器私有前缀在前，标准前缀在后</em></strong></p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 易混淆的方法整理</title>
    <url>/2018/02/23/js-easy-to-confuse-methods/</url>
    <content><![CDATA[<blockquote>
<p>js的字符串方法如<code>substr</code>、<code>substring</code>，数组方法如<code>slice</code>、<code>splice</code>等名字相近，用法稍有不同，让开发者在开发过程中总是记不起其用法，需要查资料。现整理一下，希望有助大家记忆。</p>
</blockquote>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><blockquote>
<p>stringObject.slice(start, end)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello world!'</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.slice(<span class="number">-4</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">// a: 'Hello world!'</span></span><br><span class="line"><span class="comment">// b: 'llo world!'</span></span><br><span class="line"><span class="comment">// c: 'rl'，参数可为负</span></span><br></pre></td></tr></table></figure>
<h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><blockquote>
<p>stringObject.substr(start, length)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello world!'</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.substr(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.substr(<span class="number">-5</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// a: 'Hello world!'</span></span><br><span class="line"><span class="comment">// b: 'Hell'</span></span><br><span class="line"><span class="comment">// c: 'or'，参数可为负</span></span><br></pre></td></tr></table></figure>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><blockquote>
<p>stringObject.substring(start, stop)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello world!'</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.substring(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.substring(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> d = a.substring(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// a: 'Hello world!'</span></span><br><span class="line"><span class="comment">// b: 'Hell'</span></span><br><span class="line"><span class="comment">// c: 'l'，start比stop小，交换这两个参数</span></span><br><span class="line"><span class="comment">// d: ''，参数为负，返回空字符串</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>slice、substr、substring都是字符串的切割方法，三者之间有细微的区别，根据不同的使用场景可以灵活使用。三种方法都是生成新的字符串，而不是修改原string。</p>
</blockquote>
<h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><blockquote>
<p>arrayObject.concat(arrayX, arrayX, …, arrayX)</p>
</blockquote>
<p>参数可以为具体的值，也可以为数组对象，可以任意多个。不改变现有的数组，返回被连接数组的一个副本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.concat(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.concat([<span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// a: [1, 2, 3]</span></span><br><span class="line"><span class="comment">// b: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// c: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><blockquote>
<p>arrayObject.pop()</p>
</blockquote>
<p>删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.pop();</span><br><span class="line"><span class="comment">// a: [1, 2]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: 3，返回删除元素的值</span></span><br></pre></td></tr></table></figure>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><blockquote>
<p>arrayObject.push(newelement1,newelement2,…,newelementX)\</p>
</blockquote>
<p>参数顺序添加到 arrayObject 的尾部，直接修改 arrayObject。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.push(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// a: [1, 2, 3, 4, 5]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: 5，返回修改后的数组的长度</span></span><br></pre></td></tr></table></figure>
<h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><blockquote>
<p>arrayObject.shift()</p>
</blockquote>
<p>把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。该方法会改变原数组。类比pop方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.shift();</span><br><span class="line"><span class="comment">// a: [2, 3]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: 1，返回删除元素的值</span></span><br></pre></td></tr></table></figure>
<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h3><blockquote>
<p>arrayObject.unshift(newelement1, newelement2, …., newelementX)</p>
</blockquote>
<p>向数组的开头添加一个或更多元素，并返回新的长度。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.unshift(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// a: [ 4, 5, 1, 2, 3 ]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: 5，返回修改后的数组的长度</span></span><br></pre></td></tr></table></figure>
<h3 id="slice-1"><a href="#slice-1" class="headerlink" title="slice"></a>slice</h3><blockquote>
<p>arrayObject.slice(start, end)</p>
</blockquote>
<p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。该方法不会修改原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// a: [1, 2, 3, 4, 5]，不修改原数组</span></span><br><span class="line"><span class="comment">// b: [3, 4, 5]，返回新数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> d = c.slice(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// c: [1, 2, 3, 4, 5]，不修改原数组</span></span><br><span class="line"><span class="comment">// d: [3, 4]，返回新数组</span></span><br></pre></td></tr></table></figure>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><blockquote>
<p>arrayObject.splice(index, howmany, item1, …, itemX)</p>
</blockquote>
<p>可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// a: [1, 3, 4, 5]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: [2]，返回新数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> d = c.splice(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// c: [1, 2, 3, 4]，修改了原数组</span></span><br><span class="line"><span class="comment">// d: [5]，返回新数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> f = e.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// e: [ 1, 6, 7, 3, 4, 5 ]，修改了原数组</span></span><br><span class="line"><span class="comment">// f: [2]，返回新数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> h = g.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// g: [ 1, 8, 2, 3, 4, 5 ]，修改了原数组</span></span><br><span class="line"><span class="comment">// h: []，没有删除值，返回空数组</span></span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><blockquote>
<p>arrayObject.sort(sortBy)</p>
</blockquote>
<p>无参数时，将按字母顺序对数组中的元素进行排序。参数为比较函数时，如果要交换 prev 和 next 的值，返回大于 0 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.sort(<span class="function"><span class="keyword">function</span> (<span class="params">prev, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev - next;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a: [1, 6, 8, 9, 10]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: [1, 6, 8, 9, 10]，返回修改后的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><blockquote>
<p>arrayObject.reverse()</p>
</blockquote>
<p>用于颠倒数组中元素的顺序。会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reverse();</span><br><span class="line"><span class="comment">// a: [3, 2, 1]，修改了原数组</span></span><br><span class="line"><span class="comment">// b: [3, 2, 1]，返回修改后的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote>
<p>arrayObject.map(function(currentValue, index, arrayObject) {})</p>
</blockquote>
<p>对数组的每一项进行处理，返回新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function">(<span class="params">curVal</span>) =&gt;</span> curVal * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// a: [1, 2, 3]，不修改原数组</span></span><br><span class="line"><span class="comment">// b: [2, 4, 6]，返回新数组</span></span><br></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><blockquote>
<p>arrayObject.forEach(function(currentValue, index, arrayObject) {})</p>
</blockquote>
<p>数组的每个元素执行一次提供的函数。一般来说不修改原数组，但也可以通过处理函数修改原数组。该方法很灵活，可类比<code>for...of</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.forEach(<span class="function">(<span class="params">curVal</span>) =&gt;</span> sum += curVal);</span><br><span class="line"><span class="comment">// a: [1, 2, 3]，不修改原数组</span></span><br><span class="line"><span class="comment">// b: undefined，forEach不返回值</span></span><br><span class="line"><span class="comment">// sum: 6</span></span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote>
<p>arrayObject.find(function(currentValue, index, arrayObject) {})</p>
</blockquote>
<p>返回数组中第一个满足测试条件（返回 true ）的元素。如果不存在这样的元素，返回undefined。findIndex类似，只不过返回的是第一个满足测试条件的元素的index。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.find(<span class="function">(<span class="params">curVal</span>) =&gt;</span> curVal === <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.find(<span class="function">(<span class="params">curVal</span>) =&gt;</span> curVal === <span class="number">4</span>);</span><br><span class="line"><span class="comment">// a: [1, 2, 3]，不修改原数组</span></span><br><span class="line"><span class="comment">// b: 1</span></span><br><span class="line"><span class="comment">// c: undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><blockquote>
<p>arrayObject.filter(function(currentValue, index, arrayObject) {})</p>
</blockquote>
<p>返回数组中所有满足测试条件（返回 true ）的元素组成的数组。如果不存在这样的元素，返回[]。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.filter(<span class="function">(<span class="params">curVal</span>) =&gt;</span> curVal &gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.filter(<span class="function">(<span class="params">curVal</span>) =&gt;</span> curVal &gt; <span class="number">3</span>);</span><br><span class="line"><span class="comment">// a: [1, 2, 3]，不修改原数组</span></span><br><span class="line"><span class="comment">// b: [2, 3]</span></span><br><span class="line"><span class="comment">// c: []</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><blockquote>
<p>arrayObject.filter(function(previousValue, currentValue, currentIndex, arrayObject) {}, initialValue)</p>
</blockquote>
<p>接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</p>
<p>如果没有 initialValue 参数, reduce 从 index 为 1 开始执行回调函数,跳过第一个 index。如果有 initialValue 参数, reduce 将从 index 为 0 开始执行回调。如果数组是空的并且没有 initialValue 参数,将会抛出 TypeError 错误。如果数组只有一个元素并且没有初始值 initialValue ,或者有 initialValue 但数组是空的, 这个唯一的值直接被返回而不会调用回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reduce(<span class="function">(<span class="params">prevResult, curItem</span>) =&gt;</span> prevResult + curItem);</span><br><span class="line"><span class="comment">// a: [1, 2, 3]，不修改原数组</span></span><br><span class="line"><span class="comment">// b: 6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了 Array 的<code>pop</code>、<code>push</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code> 这 7 个方法会修改原数组，其他方法均不会修改原数组。</p>
</blockquote>
<p><a href="https://juejin.im/post/5a8e3b08f265da4e9449c50e" target="_blank" rel="noopener">查看原文</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 备忘录</title>
    <url>/2018/02/22/git-memo/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2018/02/22/git-memo/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>Git 的一些常用操作备忘。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装好 Git 之后，配置你的资料:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.name</span><br><span class="line"><span class="comment"># 配置邮箱地址</span></span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>
<h2 id="生成-SSH-密钥"><a href="#生成-SSH-密钥" class="headerlink" title="生成 SSH 密钥"></a>生成 SSH 密钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C <span class="string">'your@email.address'</span> -t rsa</span><br></pre></td></tr></table></figure>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 git 项目</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 添加一个叫 origin 的源</span></span><br><span class="line"><span class="comment"># 使用 ssh 地址</span></span><br><span class="line">git remote add origin git@github.com:username/reponame.git</span><br><span class="line"><span class="comment"># 使用 username/password 登录 https 地址</span></span><br><span class="line">git remote add origin https://username@password:github.com/username/reponame.git</span><br></pre></td></tr></table></figure>
<h2 id="推送到服务器"><a href="#推送到服务器" class="headerlink" title="推送到服务器"></a>推送到服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录所有新增和删除的文件</span></span><br><span class="line">git add -A</span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit -m <span class="string">"message"</span></span><br><span class="line"><span class="comment"># 推送到服务器端</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h2 id="更新到本地"><a href="#更新到本地" class="headerlink" title="更新到本地"></a>更新到本地</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源 + 分支名</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆到以这个项目名命名的文件夹</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/username/reponame.git</span><br><span class="line"><span class="comment"># 克隆到你自定义的文件夹</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/username/reponame.git name</span><br></pre></td></tr></table></figure>
<h2 id="gh-pages"><a href="#gh-pages" class="headerlink" title="gh-pages"></a>gh-pages</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 dist 目录推送到 gh-pages 分支</span></span><br><span class="line">git subtree push --prefix dist origin gh-pages</span><br></pre></td></tr></table></figure>
<p><em>To be continued…</em></p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>Material Design 涟漪效果</title>
    <url>/2018/01/26/material-design-ripple-effect/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2018/01/26/material-design-ripple-effect/header-img.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>分析 Material Design 的 Button Ripple Effect 不难发现，涟漪的扩散是在 Button 的内部进行的，所以我们需要在触发的时候向其内部加入<code>span</code>（自定义）。</p>
<h3 id="扩散半径"><a href="#扩散半径" class="headerlink" title="扩散半径"></a>扩散半径</h3><p><code>span</code>是以圆向四周扩散，为完全扩散到<code>button</code>边缘，<code>span</code>的直径应是<code>button</code>宽高最长那一边的 2 倍。</p>
<h3 id="扩散中心点"><a href="#扩散中心点" class="headerlink" title="扩散中心点"></a>扩散中心点</h3><p>扩散是以鼠标点击为中心，所以我们需要获取到鼠标点击相对<code>button</code>的位置，但这还不够，因为扩散是从中心开始的，所以还要减去<code>span</code>的半径长度，如下图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2018/01/26/material-design-ripple-effect/1-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li><p><strong>left = clentX - button.left - 直径 / 2</strong></p>
</li>
<li><p><strong>top = clentX - button.top - 直径 / 2</strong></p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><script async src="//jsfiddle.net/xyue/co1pne81/embed/"></script>

<p>实际应该在<code>button</code>内部扩充一个<code>span</code>填满整个<code>button</code>，再赋予这个<code>span</code>添加涟漪的点击效果，这样<code>button</code>就不会因为必须添加 <em>position: relative;overflow: hidden;</em> 而影响布局了，小伙伴赶快去试试吧！😉</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://idiotwu.me/material-design-ripple-effect-with-css3-and-javascript/" target="_blank" rel="noopener">Material Design 水波纹点按效果</a></p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 黑魔法小技巧 [ing...]</title>
    <url>/2017/12/15/css-magic-skill/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="利用-content-属性-attr-抓取资料"><a href="#利用-content-属性-attr-抓取资料" class="headerlink" title="利用 content 属性 attr 抓取资料"></a>利用 content 属性 attr 抓取资料</h2><blockquote>
<p>鼠标悬浮提示文字，类似 github 的这种，如图：</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/1-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>相信大家第一想到的就是伪元素——<code>after</code>、<code>before</code>，利用 content 来显示不同的提示文字，但不同元素提示文字不一定相同。在不能使用 javascript 的前提条件下，我们该如何去控制 content 的内容呢？</p>
<p>利用 content 属性<code>attr</code>抓取资料。<br>在 attr 里面写入 html 中属性名称，这样伪元素 (:after) 就能获取到该属性的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-msg</span>=<span class="string">"Open this file in Github Desktop"</span>&gt;</span>hover<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">		<span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">position</span>:relative;</span><br><span class="line">		<span class="attribute">cursor</span>: pointer;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">attr</span>(data-msg);</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#1b1f23</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果，如图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/1-2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>除此之外，你还可以结合其他选择器使用，例如：<strong>使用属性选择器选择空链接</strong></p>
<p>显示没有文本值但是<code>href</code>属性具有链接的<code>a</code>元素的链接：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">"http"</span>]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tab-切换"><a href="#tab-切换" class="headerlink" title="tab 切换"></a>tab 切换</h2><p>实现 Tab 切换的难点在于如何使用 CSS 接收到用户的点击事情并对相关的节点进行操作。即：</p>
<ol>
<li>如何接收点击事件</li>
<li>如何操作相关DOM</li>
</ol>
<p>这里我们采用<code>:target</code>伪类接收点击事件。</p>
<blockquote>
<p>URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。<code>:target</code>选择器可用于选取当前活动的目标元素。</p>
</blockquote>
<p>在 :target 触发的时候分别去操作相关 DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tab1"</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tab2"</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab1"</span>&gt;</span>111111111111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab2"</span>&gt;</span>222222222222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#tab1</span>,<span class="selector-id">#tab2</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#tab1</span><span class="selector-pseudo">:target</span>,<span class="selector-id">#tab2</span><span class="selector-pseudo">:target</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/2-1.gif" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>至此，两个问题都已经解决，剩下的就是一些样式的修补工作。</p>
<h2 id="自定义文字下划线"><a href="#自定义文字下划线" class="headerlink" title="自定义文字下划线"></a>自定义文字下划线</h2><p>使用<code>linear-gradient</code>定义下划线</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"wave"</span>&gt;</span>南月凡歆<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dashed"</span>&gt;</span>南月凡歆<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">110%</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  波浪线，渐变构造'X'，截取上半部分，得到一个'V',从而结合 repeat 形成波浪线 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-class">.wave</span><span class="selector-pseudo">:after</span> &#123;  </span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, transparent, transparent <span class="number">45%</span>, red, transparent <span class="number">55%</span>, transparent <span class="number">100%</span>),</span><br><span class="line">	<span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent, transparent <span class="number">45%</span>, red, transparent <span class="number">55%</span>, transparent <span class="number">100%</span>);</span><br><span class="line">	<span class="attribute">background-size</span>: <span class="number">6px</span> <span class="number">6px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-class">.dashed</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,#<span class="number">03</span>A9F4 <span class="number">50%</span>,transparent <span class="number">0</span>);</span><br><span class="line">	<span class="attribute">background-size</span>: <span class="number">6px</span> <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/3-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="利用-pointer-events-禁用事件效果"><a href="#利用-pointer-events-禁用事件效果" class="headerlink" title="利用 pointer-events 禁用事件效果"></a>利用 pointer-events 禁用事件效果</h2><p><code>pointer-events</code>：字面理解是鼠标事件。</p>
<p>当使用 pointer-events:none 时，表示它将捕获不到任何事件，而只是让事件穿透到它的下面。</p>
<blockquote>
<p>场景：在做<code>tab</code>切换的时候，当选中当前项，禁用当前标签的事件，只有切换其他<code>tab</code>的时候，才重新请求新的数据。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"tab active"</span> <span class="attr">href</span>=<span class="string">"https://google.com"</span>&gt;</span>google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"tab"</span> <span class="attr">href</span>=<span class="string">"https://facebook.com"</span>&gt;</span>facebook<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"tab"</span> <span class="attr">href</span>=<span class="string">"https://stackoverflow.com"</span>&gt;</span>stackoverflow<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">	<span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适合 pointer-events 的场景有很多。禁用事件；作为覆盖物不影响下层操作，遇到这类情况都可以考虑喲。</p>
<h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><p>移动端用 rem 布局时候，根据不同的屏幕宽度要设置不同的 font-size 来做到适配。</p>
<blockquote>
<p>例如：以<code>750px</code>设计稿作为基准，根节点设置 font-size 为 100px，只考虑 DPR 为 2 的最简情况。</p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'html'</span>).style.fontSize = <span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.innerWidth <span class="regexp">/ 7.5 &#125;px`;</span></span></span></span><br></pre></td></tr></table></figure>
<p>等同与</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>  /  <span class="number">7.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p>在不使用图片的情况，实现一个简单的三角形箭头</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"triangle-top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-top</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">	<span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">	<span class="attribute">border-bottom</span>: <span class="number">60px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/6-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="文本溢出省略"><a href="#文本溢出省略" class="headerlink" title="文本溢出省略"></a>文本溢出省略</h2><p>有时我们会遇到这样的需求，将一段文字单行，或者多行显示，超出的部分用省略号代替。相信很多同学都曾用 javascript 截取字符串拼接省略号以达到这样的效果，但由于每个字实际表现宽度的不一致，往往需要去单独的控制截取长度。</p>
<p>但其实，用 css 就能完美的解决。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>借一盏午夜街头 昏黄灯光 照亮那坎坷路上人影一双 借一寸三九天里 冽冽暖阳 融这茫茫人间刺骨凉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">overflow </span>: hidden;</span><br><span class="line">	<span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">	<span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/7-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">overflow </span>: hidden;</span><br><span class="line">	<span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">	<span class="attribute">display</span>: -webkit-box;</span><br><span class="line">        <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/15/css-magic-skill/7-2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>深度剖析：如何实现一个 Virtual DOM 算法</title>
    <url>/2017/12/08/virtual-dom/</url>
    <content><![CDATA[<blockquote>
<p>载自 <a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">《深度剖析：如何实现一个 Virtual DOM 算法》</a> —— <em><a href="https://github.com/livoras" target="_blank" rel="noopener">Livoras</a></em></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。</p>
<p>本文所实现的完整代码存放在 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">Github</a>。</p>
<h2 id="对前端应用状态管理的思考"><a href="#对前端应用状态管理的思考" class="headerlink" title="对前端应用状态管理的思考"></a>对前端应用状态管理的思考</h2><p>假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/08/virtual-dom/sort-table.png" alt="sort-table.png" title>
                </div>
                <div class="image-caption">sort-table.png</div>
            </figure>
<p>这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortKey = <span class="string">"new"</span> <span class="comment">// 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数</span></span><br><span class="line"><span class="keyword">var</span> sortType = <span class="number">1</span> <span class="comment">// 升序还是逆序</span></span><br><span class="line"><span class="keyword">var</span> data = [&#123;...&#125;, &#123;...&#125;, &#123;..&#125;, ..] <span class="comment">// 表格数据</span></span><br></pre></td></tr></table></figure>
<p>用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。</p>
<p>这样做会导致的后果就是，随着应用程序越来越复杂，需要在 JS 里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的 DOM 操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是 DOM 操作），你需要操作的 DOM 还是需要操作，只是换了个地方。</p>
<p>既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看<a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="noopener">这篇介绍</a>）。</p>
<p>MVVM 可以很好的降低我们维护状态 -&gt; 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染<strong>整个视图</strong>，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在 JS 里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下<code>innerHTML</code>就完事了。</p>
<p>听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，<code>input</code>和<code>textarea</code>的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（ Backbone 就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p>
<p><strong>但是这里要明白和记住这种做法</strong>，因为后面你会发现，其实 <strong>Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更</strong>。</p>
<p>另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：<strong>维护状态，更新视图</strong>。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。</p>
<h2 id="Virtual-DOM算法"><a href="#Virtual-DOM算法" class="headerlink" title="Virtual DOM算法"></a>Virtual DOM算法</h2><p>DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/08/virtual-dom/dom-attributes.png" alt="dom-attributes" title>
                </div>
                <div class="image-caption">dom-attributes</div>
            </figure>
<p>而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。</p>
<p>相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    id: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面对应的HTML写法是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的 DOM 树。</p>
<p>之前的章节所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。</p>
<p>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。</p>
<p>这就是所谓的 Virtual DOM 算法。包括几个步骤：</p>
<ol>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把2所记录的差异应用到步骤1所构建的真正的 DOM 树上，视图就更新了</li>
</ol>
<p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="步骤一：用JS对象模拟DOM树"><a href="#步骤一：用JS对象模拟DOM树" class="headerlink" title="步骤一：用JS对象模拟DOM树"></a>步骤一：用JS对象模拟DOM树</h3><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点：</p>
<p>element.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">  <span class="keyword">this</span>.props = props</span><br><span class="line">  <span class="keyword">this</span>.children = children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如上面的 DOM 结构就可以简单的表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">'./element'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">'ul'</span>, &#123;<span class="attr">id</span>: <span class="string">'list'</span>&#125;, [</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 2'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 3'</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>现在<code>ul</code>只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个<code>ul</code>构建真正的<code>&lt;ul&gt;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName) <span class="comment">// 根据tagName构建</span></span><br><span class="line">  <span class="keyword">var</span> props = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123; <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> children = <span class="keyword">this</span>.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> Element)</span><br><span class="line">      ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">      : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>render</code>方法会根据<code>tagName</code>构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ulRoot = ul.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot)</span><br></pre></td></tr></table></figure>
<p>上面的<code>ulRoot</code>是真正的 DOM 节点，把它塞入文档中，这样<code>body</code>里面就有了真正的<code>&lt;ul&gt;</code> 的DOM结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>完整代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="noopener">element.js</a>。</p>
<h3 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异</h3><p>正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动 DOM 元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/08/virtual-dom/compare-in-level.png" alt="compare-in-level" title>
                </div>
                <div class="image-caption">compare-in-level</div>
            </figure>
<p>上面的<code>div</code>只会和同一层级的<code>div</code>对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p>
<h4 id="深度优先遍历，记录差异"><a href="#深度优先遍历，记录差异" class="headerlink" title="深度优先遍历，记录差异"></a>深度优先遍历，记录差异</h4><p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/08/virtual-dom/dfs-walk.png" alt="dfs-walk" title>
                </div>
                <div class="image-caption">dfs-walk</div>
            </figure>
<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span> (<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span> <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = &#123;&#125; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  <span class="keyword">return</span> patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对比oldNode和newNode的不同，记录下来</span></span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span> (<span class="params">oldChildren, newChildren, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> leftNode = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count) <span class="comment">// 计算节点的标识</span></span><br><span class="line">      ? currentNodeIndex + leftNode.count + <span class="number">1</span></span><br><span class="line">      : currentNodeIndex + <span class="number">1</span></span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches) <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，上面的<code>div</code>和新的<code>div</code>有差异，当前的标记是 0，那么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;difference&#125;, &#123;difference&#125;, ...] <span class="comment">// 用数组存储新旧节点的不同</span></span><br></pre></td></tr></table></figure>
<p>同理<code>p</code>是<code>patches[1]</code>，<code>ul</code>是<code>patches[3]</code>，类推。</p>
<h4 id="差异类型"><a href="#差异类型" class="headerlink" title="差异类型"></a>差异类型</h4><p>上面说的节点的差异指的是什么呢？对 DOM 操作可能会：</p>
<ol>
<li>替换掉原来的节点，例如把上面的<code>div</code>换成了<code>section</code></li>
<li>移动、删除、新增子节点，例如上面<code>div</code>的子节点，把<code>p</code>和<code>ul</code>顺序互换</li>
<li>修改了节点的属性</li>
<li>对于文本节点，文本内容可能会改变。例如修改上面的文本节点 2 内容为<code>Virtual DOM 2</code>。</li>
</ol>
<p>所以我们定义了几种差异类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REPLACE = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> REORDER = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> PROPS = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> TEXT = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>对于节点替换，很简单。判断新旧节点的<code>tagName</code>和是不是一样的，如果不一样的说明需要替换掉。如<code>div</code>换成<code>section</code>，就记录下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode <span class="comment">// el('section', props, children)</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>如果给<code>div</code>新增了属性<code>id</code>为<code>container</code>，就记录下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode <span class="comment">// el('section', props, children)</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  type: PROPS,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: <span class="string">"container"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>如果是文本节点，如上面的文本节点2，就记录下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">2</span>] = [&#123;</span><br><span class="line">  type: TEXT,</span><br><span class="line">  content: <span class="string">"Virtual DOM2"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>那如果把我<code>div</code>的子节点重新排序呢？例如<code>p</code>,<code>ul</code>,<code>div</code>的顺序换成了<code>div</code>,<code>p</code>,<code>ul</code>。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 <code>p</code>和<code>div</code>的<code>tagName</code>不同，<code>p</code>会被<code>div</code>所替代。最终，三个节点都会被替换，这样<code>DOM</code>开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。</p>
<p>这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。</p>
<h4 id="列表对比算法"><a href="#列表对比算法" class="headerlink" title="列表对比算法"></a>列表对比算法</h4><p>假设现在可以英文字母唯一地标识每一个子节点：</p>
<p>旧的节点顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a b c d e f g h i</span><br></pre></td></tr></table></figure>
<p>现在对节点进行了删除、插入、移动的操作。新增<code>j</code>节点，删除<code>e</code>节点，移动<code>h</code>节点：</p>
<p>新的节点顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a b c h d f g i j</span><br></pre></td></tr></table></figure>
<p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">Edition Distance</a>），最常见的解决算法是 <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="noopener">Levenshtein Distance</a>，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定 DOM 操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考<a href="https://github.com/livoras/list-diff/blob/master/lib/diff.js" target="_blank" rel="noopener">代码</a>。</p>
<p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;</span><br><span class="line">  type: REORDER,</span><br><span class="line">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>但是要注意的是，因为<code>tagName</code>是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识<code>key</code>，列表对比的时候，使用<code>key</code>进行对比，这样才能复用老的 DOM 树上的节点。</p>
<p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="noopener">diff.js</a>。</p>
<h3 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上"></a>步骤三：把差异应用到真正的DOM树上</h3><p>因为步骤一所构建的 JavaScript 对象树和<code>render</code>出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的<code>patches</code>对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.index] <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    <span class="keyword">var</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">currentPatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="noopener">patch.js</a>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Virtual DOM 算法主要是实现上面步骤的三个函数：<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="noopener">element</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="noopener">diff</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="noopener">patch</a>。然后就可以实际的进行使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构建虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> tree = el(<span class="string">'div'</span>, &#123;<span class="string">'id'</span>: <span class="string">'container'</span>&#125;, [</span><br><span class="line">    el(<span class="string">'h1'</span>, &#123;<span class="attr">style</span>: <span class="string">'color: blue'</span>&#125;, [<span class="string">'simple virtal dom'</span>]),</span><br><span class="line">    el(<span class="string">'p'</span>, [<span class="string">'Hello, virtual-dom'</span>]),</span><br><span class="line">    el(<span class="string">'ul'</span>, [el(<span class="string">'li'</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过虚拟DOM构建真正的DOM</span></span><br><span class="line"><span class="keyword">var</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 生成新的虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> newTree = el(<span class="string">'div'</span>, &#123;<span class="string">'id'</span>: <span class="string">'container'</span>&#125;, [</span><br><span class="line">    el(<span class="string">'h1'</span>, &#123;<span class="attr">style</span>: <span class="string">'color: red'</span>&#125;, [<span class="string">'simple virtal dom'</span>]),</span><br><span class="line">    el(<span class="string">'p'</span>, [<span class="string">'Hello, virtual-dom'</span>]),</span><br><span class="line">    el(<span class="string">'ul'</span>, [el(<span class="string">'li'</span>), el(<span class="string">'li'</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 比较两棵虚拟DOM树的不同</span></span><br><span class="line"><span class="keyword">var</span> patches = diff(tree, newTree)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 在真正的DOM元素上应用变更</span></span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure>
<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。</p>
<p>本文所实现的完整代码存放在 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">Github</a>，仅供学习。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/Matt-Esch/virtual-dom/blob/master/vtree/diff.js" target="_blank" rel="noopener">https://github.com/Matt-Esch/virtual-dom/blob/master/vtree/diff.js</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>virtual-dom</tag>
      </tags>
  </entry>
  <entry>
    <title>js 代码重构细节</title>
    <url>/2017/12/06/js-restructure-points/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/12/06/js-restructure-points/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p>
</blockquote>
<p>伴随软件的迭代，功能的日益复杂，由于没有理解原来程序的结构和考虑代码的扩展性，程序慢慢的失去了原来的结构，之前的设计变得面目全非。如果不进行重构，程序就会越来越难以维护。</p>
<h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><ol>
<li>改进软件设计 <em>—— 原来的设计没考虑到一些未知的情况，导致其后加入的功能破坏原有设计</em></li>
<li>使软件更容易理解</li>
<li>帮助找到bug <em>—— 重构可以增加对代码的理解，从而更容易</em></li>
<li>提高编程速度 <em>—— 重构虽然花费时间，但重构可以改善程序的设计，使添加新特性更容易</em></li>
</ol>
<h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><p>重构应该随时进行，当加入新功能时不是特别容易时，可以通过重构使添加新特性更容易，修补错误时更容易发现Bug，复审代码也是重构的好时机。</p>
<h2 id="重构细节"><a href="#重构细节" class="headerlink" title="重构细节"></a>重构细节</h2><p>在实际的项目重构有一些常见而容易忽略的细节，这些细节也是帮助我们达到重构目标的重要手段。有一部分思想来自 <strong>Martin Fowler</strong> 的名著 <a href="http://p02hf9fn0.bkt.clouddn.com/重构：改善既有代码的设计.pdf" target="_blank" rel="noopener">《重构：改善既有代码的设计》</a>，虽然该书是使用 <code>Java</code> 语言写成的，但这些重构的技巧，有很大一部分可以为 <code>JavaScript</code> 语言所借鉴。</p>
<h3 id="提炼函数"><a href="#提炼函数" class="headerlink" title="提炼函数"></a>提炼函数</h3><p>如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另外一个独立的函数中。这是一种很常见的优化工作，这样做的好处主要有以下几点。</p>
<ul>
<li>避免出现超大函数</li>
<li>独立出来的函数有助于代码复用</li>
<li>独立出来的函数更容易被覆写</li>
<li>独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(<span class="string">'http:// xxx.com/userInfo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'userId: '</span> + data.userId);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'userName: '</span> + data.userName);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'nickName: '</span> + data.nickName);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(<span class="string">'http:// xxx.com/userInfo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        printDetails(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> printDetails = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'userId: '</span> + data.userId);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'userName: '</span> + data.userName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nickName: '</span> + data.nickName);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="合并重复的条件片段"><a href="#合并重复的条件片段" class="headerlink" title="合并重复的条件片段"></a>合并重复的条件片段</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paging = <span class="function"><span class="keyword">function</span> (<span class="params">currPage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currPage &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        currPage = <span class="number">0</span>;</span><br><span class="line">        jump(currPage); <span class="comment">// 跳转</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class="line">        currPage = totalPage;</span><br><span class="line">        jump(currPage); <span class="comment">// 跳转</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jump(currPage); <span class="comment">// 跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paging = <span class="function"><span class="keyword">function</span> (<span class="params">currPage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currPage &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        currPage = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class="line">        currPage = totalPage;</span><br><span class="line">    &#125;</span><br><span class="line">    jump(currPage); <span class="comment">// 把 jump 函数独立出来</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="把条件分支语句提炼成函数"><a href="#把条件分支语句提炼成函数" class="headerlink" title="把条件分支语句提炼成函数"></a>把条件分支语句提炼成函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>) &#123; <span class="comment">// 夏天</span></span><br><span class="line">        <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSummer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSummer()) &#123; <span class="comment">// 夏天</span></span><br><span class="line">        <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="合理使用循环"><a href="#合理使用循环" class="headerlink" title="合理使用循环"></a>合理使用循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2.XMLHttp.6.0'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2.XMLHttp.3.0'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2.XMLHttp'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> versions = [<span class="string">'MSXML2.XMLHttp.6.0ddd'</span>, <span class="string">'MSXML2.XMLHttp.3.0'</span>, <span class="string">'MSXML2.XMLHttp'</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, version; version = versions[i++];) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(version);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="提前让函数退出代替嵌套条件分支"><a href="#提前让函数退出代替嵌套条件分支" class="headerlink" title="提前让函数退出代替嵌套条件分支"></a>提前让函数退出代替嵌套条件分支</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> del = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (!obj.isReadOnly) &#123; <span class="comment">// 不为只读的才能被删除</span></span><br><span class="line">        <span class="keyword">if</span> (obj.isFolder) &#123; <span class="comment">// 如果是文件夹</span></span><br><span class="line">            ret = deleteFolder(obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.isFile) &#123; <span class="comment">// 如果是文件</span></span><br><span class="line">            ret = deleteFile(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> del = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.isReadOnly) &#123; <span class="comment">// 反转 if 表达式</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj.isFolder) &#123;</span><br><span class="line">        <span class="keyword">return</span> deleteFolder(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj.isFile) &#123;</span><br><span class="line">        <span class="keyword">return</span> deleteFile(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="传递对象参数代替过长的参数列表"><a href="#传递对象参数代替过长的参数列表" class="headerlink" title="传递对象参数代替过长的参数列表"></a>传递对象参数代替过长的参数列表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setUserInfo = <span class="function"><span class="keyword">function</span> (<span class="params">id, name, address, sex, mobile, qq</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id= '</span> + id);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name= '</span> + name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'address= '</span> + address);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sex= '</span> + sex);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mobile= '</span> + mobile);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'qq= '</span> + qq);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setUserInfo = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id= '</span> + obj.id);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name= '</span> + obj.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'address= '</span> + obj.address);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sex= '</span> + obj.sex);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mobile= '</span> + obj.mobile);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'qq= '</span> + obj.qq);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="尽量减少参数数量"><a href="#尽量减少参数数量" class="headerlink" title="尽量减少参数数量"></a>尽量减少参数数量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> draw = <span class="function"><span class="keyword">function</span> (<span class="params">width, height, square</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> draw = <span class="function"><span class="keyword">function</span> (<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> square = width * height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="少用三目运算符"><a href="#少用三目运算符" class="headerlink" title="少用三目运算符"></a>少用三目运算符</h3><p>如果条件分支逻辑简单且清晰，这无碍我们使用三目运算符：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></p>
<p>但如果条件分支逻辑非常复杂，如下段代码所示，那我们最好的选择还是按部就班地编写 <code>if</code>、 <code>else</code>。 <code>if</code>、 <code>else</code> 语句的好处很多，一是阅读相对容易，二是修改的时候比修改三目运算符周围的代码更加方便</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !aup || !bup ) &#123;   <span class="comment">// 头痛吧</span></span><br><span class="line">    <span class="keyword">return</span> a === doc ? <span class="number">-1</span> :</span><br><span class="line">        b === doc ? <span class="number">1</span> :</span><br><span class="line">        aup ? <span class="number">-1</span> :</span><br><span class="line">        bup ? <span class="number">1</span> :</span><br><span class="line">        sortInput ?</span><br><span class="line">        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合理使用链式调用"><a href="#合理使用链式调用" class="headerlink" title="合理使用链式调用"></a>合理使用链式调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> User = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">User.prototype.setId = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">User.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User().setId(<span class="number">1314</span>).setName(<span class="string">'sven'</span>));</span><br></pre></td></tr></table></figure>
<p>或则↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123;</span><br><span class="line">    id: <span class="literal">null</span>,</span><br><span class="line">    name: <span class="literal">null</span>,</span><br><span class="line">    setId: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(User.setId(<span class="number">1314</span>).setName(<span class="string">'sven'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="分解大型类"><a href="#分解大型类" class="headerlink" title="分解大型类"></a>分解大型类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Spirit = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Spirit.prototype.attack = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123; <span class="comment">// 攻击</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'waveBoxing'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': 使用波动拳'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'whirlKick'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': 使用旋风腿'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> spirit = <span class="keyword">new</span> Spirit(<span class="string">'RYU'</span>);</span><br><span class="line">spirit.attack(<span class="string">'waveBoxing'</span>); <span class="comment">// 输出： RYU: 使用波动拳</span></span><br><span class="line">spirit.attack(<span class="string">'whirlKick'</span>);  <span class="comment">// 输出： RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Attack = <span class="function"><span class="keyword">function</span> (<span class="params">spirit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.spirit = spirit;</span><br><span class="line">&#125;;</span><br><span class="line">Attack.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[type].call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Attack.prototype.list = &#123;</span><br><span class="line">    waveBoxing: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.spirit.name + <span class="string">': 使用波动拳'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    whirlKick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.spirit.name + <span class="string">': 使用旋风腿'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Spirit = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.attackObj = <span class="keyword">new</span> Attack(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Spirit.prototype.attack = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123; <span class="comment">// 攻击</span></span><br><span class="line">    <span class="keyword">this</span>.attackObj.start(type);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> spirit = <span class="keyword">new</span> Spirit(<span class="string">'RYU'</span>);</span><br><span class="line">spirit.attack(<span class="string">'waveBoxing'</span>);  <span class="comment">// 输出： RYU: 使用波动拳</span></span><br><span class="line">spirit.attack(<span class="string">'whirlKick'</span>);   <span class="comment">// 输出： RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>
<h3 id="用-return-退出多重循环"><a href="#用-return-退出多重循环" class="headerlink" title="用 return 退出多重循环"></a>用 return 退出多重循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'....'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更改为↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123; </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'....'</span>);  <span class="comment">// for 循环后边的代码提取到 return 之前执行</span></span><br><span class="line">                <span class="keyword">return</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://p02hf9fn0.bkt.clouddn.com/JavaScript设计模式与开发实践.pdf.pdf" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》——曾探</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>ionic3 启动白屏解决</title>
    <url>/2017/11/27/ionic-start-white-screen/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/11/27/ionic-start-white-screen/header-img.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>APP 启动后，会有一段时间的白屏，影响体验</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>向 <code>config.xml</code> 配置文件中添加以下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">preference</span> <span class="attr">name</span>=<span class="string">"AutoHideSplashScreen"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span>    <span class="comment">&lt;!-- 禁止自动隐藏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">preference</span> <span class="attr">name</span>=<span class="string">"ShowSplashScreen"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>         <span class="comment">&lt;!-- 显示启动画面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">preference</span> <span class="attr">name</span>=<span class="string">"ShowSplashScreenSpinner"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>  <span class="comment">&lt;!-- 显示启动加载灰圈 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">preference</span> <span class="attr">name</span>=<span class="string">"FadeSplashScreen"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>         <span class="comment">&lt;!-- 启动淡出效果 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>向 <code>/src/app/main.ts</code> 文件中添加以下内容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; enableProdMode &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line">enableProdMode();<span class="comment">// 加快启动速度</span></span><br></pre></td></tr></table></figure>
<hr>
<p>完成以上步骤重新 build.</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title>全文检索引擎 Solr 搭建</title>
    <url>/2017/10/18/search-engine-solr-build/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/header-img.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。</p>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ul>
<li>window</li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 1.8</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/7.0.1/solr-7.0.1.zip" target="_blank" rel="noopener">Solr 7.0.1</a></li>
<li>oracle</li>
</ul>
<h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p>下载Solr后解压得到目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─bin               // 脚本的启动目录</span><br><span class="line">├─contrib           // 第三方 jar 包存放目录</span><br><span class="line">├─dist              // 编译打包后存放目录，即构建后的输出产物存放目录</span><br><span class="line">├─docs              // solr 的 API 文档文档存放目录</span><br><span class="line">├─example           // 示范例子的存放目录，example-DIH 目录下的是一些 solr 索引 core 样例</span><br><span class="line">├─licenses          // solr 相关的一些许可信息</span><br><span class="line">└─server            // solr 服务端工作目录，自带集成 jetty 插件方式启动 solr 服务器</span><br><span class="line">    │ start.jar     // 服务端启动 jar 包</span><br><span class="line">    ├─solr          // solr 搜索引擎工作目录，即 SOLRHOME</span><br><span class="line">    └─solr-webapp   // solr 后台管理页面 webapp</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>进入 /bin 目录， 按住 shift + 鼠标右键打开命令窗口</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/2-1.png" alt="打开命令窗口" title>
                </div>
                <div class="image-caption">打开命令窗口</div>
            </figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solr start</span><br></pre></td></tr></table></figure>
<p>启动 Solr 服务</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/2-2.png" alt="启动 Solr 服务" title>
                </div>
                <div class="image-caption">启动 Solr 服务</div>
            </figure>
<p>在浏览器中输入 <a href="http://localhost:8983" target="_blank" rel="noopener">localhost:8983</a> 访问 Solr 管理后台</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/2-3.png" alt="管理后台" title>
                </div>
                <div class="image-caption">管理后台</div>
            </figure>
<h2 id="新建索引库core"><a href="#新建索引库core" class="headerlink" title="新建索引库core"></a>新建索引库core</h2><p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solr create -c my_core</span><br></pre></td></tr></table></figure>
<p>新建名为 my_core 的 core</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/3-1.png" alt="create" title>
                </div>
                <div class="image-caption">create</div>
            </figure>
<p>创建成功后，在管理页面选择 Core Admin 可以看到刚创建的 core</p>
<p><img src="/2017/10/18/search-engine-solr-build/3-2.png" alt="Core Admin"></p>
<p>在 SOLRHOME （目录说明中有提到）下会生成 my_core 目录</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/3-3.png" alt="my_core" title>
                </div>
                <div class="image-caption">my_core</div>
            </figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─conf               // 存放core的配置文件</span><br><span class="line">│    solrconfig.xml  // 定义了这个 core 的配置信息</span><br><span class="line">│    start.jar       // 定义索引库的字段及分词器等，这个配置文件是核心文件</span><br><span class="line">└─data               // 存放core的数据，即index-索引文件和log-日志记录</span><br></pre></td></tr></table></figure>
<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>导入 oracle 表 <a href="/2017/10/18/search-engine-solr-build/news.sql">news</a> 中的数据</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/4-1.png" alt="table_news" title>
                </div>
                <div class="image-caption">table_news</div>
            </figure>
<p>在 %SOLRHOME%/my_core/conf 目录下创建 data-config.xml 文件，并写入以下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataConfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">user</span>=<span class="string">"[user]"</span> <span class="attr">password</span>=<span class="string">"[password]"</span> <span class="attr">url</span>=<span class="string">"jdbc:oracle:thin:@[host]:[port]:[SID]"</span> <span class="attr">driver</span>=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">document</span> &gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 表中字段映射 </span></span><br><span class="line"><span class="comment">	     pk: 主键</span></span><br><span class="line"><span class="comment">	     transformer： clob 转换</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity</span> <span class="attr">name</span>=<span class="string">"news"</span> <span class="attr">pk</span>=<span class="string">"ID"</span> <span class="attr">query</span>=<span class="string">"select * from news"</span> <span class="attr">transformer</span>=<span class="string">"ClobTransformer"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"N_ID"</span>/&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"N_TITLE"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">column</span>=<span class="string">"N_CONTENT"</span> <span class="attr">clob</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"time"</span> <span class="attr">column</span>=<span class="string">"N_TIME"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 %SOLRHOME%/my_core 下创建 lib 文件夹，并将 oracle 驱动包 <a href="http://www.datanucleus.org/downloads/maven2/oracle/ojdbc6/11.2.0.3/ojdbc6-11.2.0.3.jar" target="_blank" rel="noopener">ojdbc6.jar</a> 放到该目录下<br>此时 my_core 文件结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│  core.properties</span><br><span class="line">│  </span><br><span class="line">├─conf</span><br><span class="line">│  │  data-config.xml</span><br><span class="line">│  │  dataimport.properties</span><br><span class="line">│  │  managed-schema</span><br><span class="line">│  │  params.json</span><br><span class="line">│  │  protwords.txt</span><br><span class="line">│  │  solrconfig.xml</span><br><span class="line">│  │  stopwords.txt</span><br><span class="line">│  │  synonyms.txt</span><br><span class="line">│  └─lang        </span><br><span class="line">├─data        </span><br><span class="line">└─lib</span><br><span class="line">        ojdbc6.jar</span><br></pre></td></tr></table></figure>
<p>编辑 %SOLRHOME%/my_core/conf/solrconfig.xml，添加类库和数据库配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:../../../..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-dataimporthandler-\d.*\.jar"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"/dataimport"</span> <span class="attr">class</span>=<span class="string">"solr.DataImportHandler"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span>data-config.xml<span class="tag">&lt;/<span class="name">str</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">lst</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>选择当前 my_core ,选择 Schema, 添加索引字段 <strong>（字段名称和 solrconfig.xml 中 field 相同，忽略主键）</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/4-2.png" alt="Add Filed" title>
                </div>
                <div class="image-caption">Add Filed</div>
            </figure>
<p>添加完成后，打开 %SOLRHOME%/my_core/conf/managed-schema，可以看到，此时添加索引字段已写入该文件中</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/4-3.png" alt="managed-schema" title>
                </div>
                <div class="image-caption">managed-schema</div>
            </figure>
<p>在命令台中输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solr restart -p 8983</span><br></pre></td></tr></table></figure></p>
<p>重启服务</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/4-4.png" alt="restart" title>
                </div>
                <div class="image-caption">restart</div>
            </figure>
<p>进入管理界面，选择 my_core –&gt; Dataimport –&gt; Execute 导入数据，可以点击 Refresh Status 查看导入状态</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/4-5.png" alt="Dataimport" title>
                </div>
                <div class="image-caption">Dataimport</div>
            </figure>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>选择 Query</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/5-1.png" alt="Query" title>
                </div>
                <div class="image-caption">Query</div>
            </figure>
<p>点击 Execute Query 查询数据</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/5-2.png" alt="Execute Query" title>
                </div>
                <div class="image-caption">Execute Query</div>
            </figure>
<h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><p><code>smartcn</code> 、 <code>IKAnalyzer</code> 、 <code>mmseg4j</code>，选择其中任意一种即可</p>
<h3 id="smartcn"><a href="#smartcn" class="headerlink" title="smartcn"></a>smartcn</h3><p>smartcn 是 Solr 同步发行的一个中文分词包，将 solr-7.0.1/contrib/analysis-extras/lucene-libs/lucene-analyzers-smartcn-7.0.1.jar 拷贝至 %SOLRHOME%/my_core/lib，编辑 %SOLRHOME%/my_core/conf/managed-schema 文件，添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- smartcn --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_smartcn"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- smartcn --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="IKAnalyzer"><a href="#IKAnalyzer" class="headerlink" title="IKAnalyzer"></a>IKAnalyzer</h3><blockquote>
<p>IKAnalyzer 是一个开源的，基于 java 语言开发的轻量级的中文分词工具包。</p>
</blockquote>
<p>将 <a href="https://github.com/EugenePig/ik-analyzer-solr5" target="_blank" rel="noopener">ik-analyzer-solr5</a> 打包后放至 %SOLRHOME%/my_core/lib 下<br>编辑 %SOLRHOME%/my_core/conf/managed-schema 文件，添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- IKAnalyzer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_ik"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span> <span class="attr">isMaxWordLength</span>=<span class="string">"false"</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKAnalyzer"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span> <span class="attr">isMaxWordLength</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKAnalyzer"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- IKAnalyzer --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="mmseg4j"><a href="#mmseg4j" class="headerlink" title="mmseg4j"></a>mmseg4j</h3><blockquote>
<ul>
<li>mmseg4j 用 Chih-Hao Tsai 的 MMSeg <a href="http://technology.chtsai.org/mmseg" target="_blank" rel="noopener">算法</a> 实现的中文分词器，并实现 lucene 的 analyzer 和 solr 的TokenizerFactory 以方便在Lucene和Solr中使用。</li>
<li>MMSeg 算法有两种分词方法： Simple 和 Complex，都是基于正向最大匹配。</li>
<li>mmseg4j 有三种分词模式 simple | complex | max-word，默认是 max-word。</li>
<li>mmseg4j 的词库强制使用 UTF-8。</li>
</ul>
</blockquote>
<p>下载需要的包</p>
<ul>
<li><a href="http://central.maven.org/maven2/com/chenlb/mmseg4j/mmseg4j-core/1.10.0/mmseg4j-core-1.10.0.jar" target="_blank" rel="noopener">mmseg4j-core-1.10.0.jar</a></li>
<li><a href="http://central.maven.org/maven2/com/chenlb/mmseg4j/mmseg4j-solr/2.4.0/mmseg4j-solr-2.4.0.jar" target="_blank" rel="noopener">mmseg4j-solr-2.4.0.jar</a></li>
</ul>
<p>放至 %SOLRHOME%/my_core/lib 中<br>编辑 %SOLRHOME%/my_core/conf/managed-schema 文件，添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mmseg4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_mmseg4j_complex"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"100"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory"</span> <span class="attr">mode</span>=<span class="string">"complex"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_mmseg4j_maxword"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"100"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory"</span> <span class="attr">mode</span>=<span class="string">"max-word"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_mmseg4j_simple"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"100"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory"</span> <span class="attr">mode</span>=<span class="string">"simple"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mmseg4j--&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启服务</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>分词器配置完成后，选择 Analysis，输入要分词的内容（Field Value），选择字段类型（Analyse Fieldname / FieldType [与配置信息 fieldType name 同步]），点击 Analyse Values 获取分词结果。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/6-1.png" alt="Analyse Values" title>
                </div>
                <div class="image-caption">Analyse Values</div>
            </figure>
<p>编辑 %SOLRHOME%/my_core/conf/managed-schema，修改索引字段类型为新添加分词类型其中任意一种即可，这里我们将 text_general 修改为 text_ik，重启服务后重新导入数据</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/18/search-engine-solr-build/6-2.png" alt="Modify Type" title>
                </div>
                <div class="image-caption">Modify Type</div>
            </figure>
<p>这样我们在对该字段行进搜索时就能达到分词搜索的效果了😛</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 UEditor(JSP 1.4.3版本) 遇到的问题</title>
    <url>/2017/10/12/problems-of-using-ueditor/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/12/problems-of-using-ueditor/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="ueditor简介"><a href="#ueditor简介" class="headerlink" title="ueditor简介:"></a>ueditor简介:</h2><blockquote>
<p>UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码…</p>
</blockquote>
<h2 id="遇到问题及解决方案"><a href="#遇到问题及解决方案" class="headerlink" title="遇到问题及解决方案"></a>遇到问题及解决方案</h2><h3 id="setContent报错"><a href="#setContent报错" class="headerlink" title="setContent报错"></a>setContent报错</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>当使用setContent给初始化容器设置内容时出现如下错误：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/12/problems-of-using-ueditor/2-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>异步，初始化容器并未创建完成，需等待编辑器创建完成后才能使用。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>使用setTimeout延迟一段时间后调用（不建议：由于setTimeout设置的时间与实际渲染需要的时间不一致）；</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>使用addListener(‘ready’,callback)，待编辑器创建完成后执行callback回调。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ue.addListener(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   ue.setContent(content);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="上传文件——“未找到上传数据”"><a href="#上传文件——“未找到上传数据”" class="headerlink" title="上传文件——“未找到上传数据”"></a>上传文件——“未找到上传数据”</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>无论上传什么文件均出现如下错误：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/12/problems-of-using-ueditor/2-2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ol>
<li>struts2：<br>struts2 框架默认使用 apache 的 commons-fileUpload 组件和内建的 FileUploadInterceptor 拦截器实现上传，会将 request 文件域封装到 action 中一个 File 类型的属性中，并删除 request 中的文件域，因此会上传文件失败。</li>
<li>springMVC：<br>UEditor 默认使用 commons 组件，而 springMVC 对 commons 组件进行了封装，使得上传后获取不到文件。</li>
</ol>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ol>
<li><p>struts2：<br>自定义一个 struts 过滤器，指定不对 ueditor/jsp/ 目录下的 jsp 页面进行过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStrutsFilter</span> <span class="keyword">extends</span> <span class="title">StrutsPrepareAndExecuteFilter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        String url = request.getRequestURI();         </span><br><span class="line">        System.out.println(url);         </span><br><span class="line">        <span class="keyword">if</span> (url.contains(request.getContextPath()+<span class="string">"/js/utf8-jsp/jsp/controller.jsp"</span>)) &#123;             </span><br><span class="line">            System.out.println(<span class="string">"使用自定义过滤器"</span>);             </span><br><span class="line">            chain.doFilter(req, res);         </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;             </span><br><span class="line">            System.out.println(<span class="string">"使用默认过滤器"</span>);             </span><br><span class="line">            <span class="keyword">super</span>.doFilter(req, res, chain);         </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>springMVC：<br>修改源码 upload 包下的 BinaryUploader.java 文件。<br>下载并使用源码：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/10/12/problems-of-using-ueditor/2-3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>重写 BinaryUploader.java ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryUploader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> State <span class="title">save</span><span class="params">(HttpServletRequest request,Map&lt;String, Object&gt; conf)</span> </span>&#123;</span><br><span class="line">        InputStream fileStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.NOT_MULTIPART_CONTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//修改了百度使用原生的commons上传方式</span></span><br><span class="line">            DefaultMultipartHttpServletRequest multipartRequest=(DefaultMultipartHttpServletRequest)request;</span><br><span class="line">            Iterator&lt;String&gt; fileNames=multipartRequest.getFileNames();</span><br><span class="line">            MultipartFile file=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (fileNames.hasNext())&#123;</span><br><span class="line">                file=multipartRequest.getFiles(fileNames.next()).get(<span class="number">0</span>);</span><br><span class="line">                fileStream=file.getInputStream();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fileStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.NOTFOUND_UPLOAD_DATA);</span><br><span class="line">            &#125;</span><br><span class="line">            String savePath = (String) conf.get(<span class="string">"savePath"</span>);</span><br><span class="line">            String originFileName = file.getOriginalFilename();</span><br><span class="line">            String suffix = FileType.getSuffixByFilename(originFileName);</span><br><span class="line">            originFileName = originFileName.substring(<span class="number">0</span>,originFileName.length() - suffix.length());</span><br><span class="line">            savePath = savePath + suffix;</span><br><span class="line">            <span class="keyword">long</span> maxSize = ((Long) conf.get(<span class="string">"maxSize"</span>)).longValue();</span><br><span class="line">            <span class="keyword">if</span> (!BinaryUploader.validType(suffix, (String[]) conf.get(<span class="string">"allowFiles"</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.NOT_ALLOW_FILE_TYPE);</span><br><span class="line">            &#125;</span><br><span class="line">            savePath = PathFormat.parse(savePath, originFileName);</span><br><span class="line">            String physicalPath = (String) conf.get(<span class="string">"rootPath"</span>) + savePath;</span><br><span class="line">            State storageState = StorageManager.saveFileByInputStream(fileStream,physicalPath, maxSize);</span><br><span class="line">            fileStream.close();</span><br><span class="line">            <span class="keyword">if</span> (storageState.isSuccess()) &#123;</span><br><span class="line">                storageState.putInfo(<span class="string">"url"</span>, PathFormat.format(savePath));</span><br><span class="line">                storageState.putInfo(<span class="string">"type"</span>, suffix);</span><br><span class="line">                storageState.putInfo(<span class="string">"original"</span>, originFileName + suffix);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> storageState;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.PARSE_REQUEST_ERROR);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseState(<span class="keyword">false</span>, AppInfo.IO_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validType</span><span class="params">(String type, String[] allowTypes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(allowTypes);</span><br><span class="line">        <span class="keyword">return</span> list.contains(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="上传文件消失"><a href="#上传文件消失" class="headerlink" title="上传文件消失"></a>上传文件消失</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>使用 tomcat ，已上传文件在重新部署项目后丢失。</p>
<h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>UEditor 上传配置文件 config.json 默认将上传文件上传到项目中，重新部署会清空项目文件。</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><h5 id="方法一：修改上传路径到webapps目录下"><a href="#方法一：修改上传路径到webapps目录下" class="headerlink" title="方法一：修改上传路径到webapps目录下"></a>方法一：修改上传路径到webapps目录下</h5><p>第一步：<br>将配置文件中上传保存路径<br><code>/ueditor/jsp/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}</code><br>修改为<br><code>/../ueditor/jsp/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}</code></p>
<p>第二步：<br>修改返回文件请求地址，将重写后 BinaryUploader.java 第33行的<br><code>PathFormat.format(savePath)</code><br>修改为<br><code>PathFormat.format(savePath).replace(&quot;/..&quot;, &quot;&quot;)</code></p>
<h5 id="方法二：配置-tomcat-虚拟目录"><a href="#方法二：配置-tomcat-虚拟目录" class="headerlink" title="方法二：配置 tomcat 虚拟目录"></a>方法二：配置 tomcat 虚拟目录</h5><p>第一步：<br>打开 %TOMCAT_HOME%/conf/server.xml（即tomcat的安装目录下面相关的文件），在 Host 中加入如下代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/ueditor"</span> <span class="attr">docBase</span>=<span class="string">"D:\ueditor"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>第二步：<br>修改上传路径，将重写后 BinaryUploader.java 第29行的<br><code>(String) conf.get(&quot;rootPath&quot;) + savePath</code><br>修改为<br><code>&quot;D://&quot; + savePath</code></p>
<p><strong>上传路径与虚拟目录 docBase 保持一致</strong></p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>富文本编辑器</tag>
        <tag>UEditor</tag>
      </tags>
  </entry>
  <entry>
    <title>Master-Worker 设计模式</title>
    <url>/2017/09/30/master-worker-design/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/09/30/master-worker-design/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Master-Worker是常用的并行计算模式。它的核心思想是系统由两类进程协作工作：</p>
<ul>
<li>Master进程：负责接收和分配任务</li>
<li>Worker进程：负责处理子任务</li>
</ul>
<p>当各个Worker子进程处理完成后 ，会将结果返回给Master，由Master作归纳总结。其好处就是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。各角色关系如下图所示：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/09/30/master-worker-design/1-1.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure><br>Master进程为主要进程，它维护一个Worker进程队列、子任务队列和子结果集。Worker进程队列中的Worker进程不停从任务队列中提取要处理的子任务，并将结果写入结果集。    </p>
<p><img src="/2017/09/30/master-worker-design/1-2.jpg" alt><br>根据上面的思想，我们来模拟一下这种经典设计模式的实现。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><ol>
<li>既然Worker是具体的执行任务，那么Worker一定要实现Runnable接口</li>
<li>Matser作为接受和分配任务，得先有个容器来装载用户发出的请求，在不考虑阻塞的情况下我们选择ConcurrentLinkedQueue作为装载容器</li>
<li>Worker对象需要能从Master接收任务，它也得有Master ConcurrentLinkedQueue容器的引用</li>
<li>Master还得有个容器需要能够装载所有的Worker，可以使用HashMap&lt;String,Thread&gt;</li>
<li>Worker处理完后需要将数据返回给Master，那么Master需要有个容器能够装载所有worker并发处理任务的结果集。此容器需要能够支持高并发，所以最好采用ConcurrentHashMap&lt;String,Object&gt;</li>
<li>同理由于Worker处理完成后将数据填充进Master的ConcurrentHashMap，那么它也得有一份ConcurrentHashMap的引用 </li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Task任务对象"><a href="#Task任务对象" class="headerlink" title="Task任务对象"></a>Task任务对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Master对象"><a href="#Master对象" class="headerlink" title="Master对象"></a>Master对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务集合</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Task&gt; taskQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的处理结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String,Object&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的Worker集合</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,Thread&gt; workerMap = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，初始化Worker</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(Worker worker,<span class="keyword">int</span> workerCount)</span></span>&#123;</span><br><span class="line">        <span class="comment">//每一个worker对象都需要有Master的引用，taskQueue用于任务的提取，resultMap用于任务的提交</span></span><br><span class="line">        worker.setTaskQueue(<span class="keyword">this</span>.taskQueue);</span><br><span class="line">        worker.setResultMap(<span class="keyword">this</span>.resultMap);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; workerCount; i++)&#123;</span><br><span class="line">            <span class="comment">//key表示worker的名字,value表示线程执行对象</span></span><br><span class="line">            workerMap.put(<span class="string">"worker"</span>+i,<span class="keyword">new</span> Thread(worker));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于提交任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行方法，启动应用程序让所有的Worker工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Thread&gt; me : workerMap.entrySet())&#123;</span><br><span class="line">            me.getValue().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断所有的线程是否都完成任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Thread&gt; me : workerMap.entrySet())&#123;</span><br><span class="line">           <span class="keyword">if</span>(me.getValue().getState() != Thread.State.TERMINATED)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结归纳 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : resultMap.entrySet()) &#123;</span><br><span class="line">            ret+=(Integer) entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Worker对象"><a href="#Worker对象" class="headerlink" title="Worker对象"></a>Worker对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Task&gt; taskQueue;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; resultMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskQueue</span><span class="params">(ConcurrentLinkedQueue&lt;Task&gt; taskQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultMap</span><span class="params">(ConcurrentHashMap&lt;String, Object&gt; resultMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultMap = resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Task executeTask = <span class="keyword">this</span>.taskQueue.poll();</span><br><span class="line">            <span class="keyword">if</span>(executeTask == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//真正的任务处理</span></span><br><span class="line">            Object result = handle(executeTask);</span><br><span class="line">            <span class="keyword">this</span>.resultMap.put(executeTask.getName(),result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心处理逻辑，可以抽离出来由具体子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handle</span><span class="params">(Task executeTask)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//表示处理任务的耗时....</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            result = executeTask.getPrice();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Client调用"><a href="#Client调用" class="headerlink" title="Client调用"></a>Client调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际开发中多少个线程最好写成Runtime.getRuntime().availableProcessors()</span></span><br><span class="line">        Master master = <span class="keyword">new</span> Master(<span class="keyword">new</span> Worker(), <span class="number">10</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt;= <span class="number">100</span> ;i++)&#123;</span><br><span class="line">            Task task = <span class="keyword">new</span> Task();</span><br><span class="line">            task.setId(i);</span><br><span class="line">            task.setName(<span class="string">"任务"</span>+i);</span><br><span class="line">            task.setPrice(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            master.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        master.execute();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(master.isComplete())&#123;</span><br><span class="line">                <span class="keyword">long</span> end  = System.currentTimeMillis() - start;</span><br><span class="line">                <span class="keyword">int</span> ret = master.getResult();</span><br><span class="line">                System.out.println(<span class="string">"计算结果:"</span>+ret+<span class="string">",执行耗时:"</span>+end);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>在Worker对象中的核心处理业务逻辑<code>handle</code>方法最好抽象成公共方法，具体实现由子类覆写。</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 中的值传递</title>
    <url>/2017/09/12/value-passing-in-js/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/09/12/value-passing-in-js/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递?"></a>值传递?</h2><p>相信在看到这个标题时，很多童鞋都会有这样的疑惑——“What?不是还有引用传递么”。<br>像这样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span> : <span class="string">'lilei'</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">'hanmeimei'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name);  <span class="comment">//output: hanmeimei</span></span><br><span class="line">&#125;</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">//output: hanmeimei</span></span><br></pre></td></tr></table></figure></p>
<p>确实，对象person属性name的值被改变了，最初的我对此也是深信不疑。<br>在《JavaScript高级程序设计》第三版 4.1.3中，关于参数的传递这样讲到：</p>
<blockquote>
<p>ECMAScript中所有函数的参数都是按值传递的。</p>
</blockquote>
<p>啥子哎！连红宝书都这样说，那可得好好深究下。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在解开疑惑前，我们先了解下什么是按值传递(call by value)，什么是按引用传递(call by reference)。<br>在计算机科学里，这个部分叫求值策略(Evaluation Strategy)。它决定变量之间、函数调用时实参和形参之间值是如何传递的。</p>
<h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><ul>
<li><p>值传递(call by value)<br>常用的求值策略，函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。</p>
</li>
<li><p>引用传递(call by reference)<br>函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。</p>
<ul>
<li><p>基本数据类型：<br>保存在栈内存中的简单数据段，常见的基本数据类型 <code>Number</code>、<code>String</code> 、<code>Boolean</code>、<code>Null</code>和<code>Undefined</code>，最新的ECMAScript标准定义加入了<code>Symbol</code>。</p>
</li>
<li><p>引用数据类型：<br>保存在堆内存中的由多个值构成的对象，比如：<code>Array</code>、<code>Function</code>和<code>Object</code>，从底层技术上看，它们三都是对象。<br>与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p>
</li>
</ul>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递?"></a>引用传递?</h2><p>如果一个基本数据类型绑定给某个变量，我们可以认为该变量包含这个基本数据类型的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'lilei'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    n = <span class="string">'hanmeimei'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);     <span class="comment">//output: hanmeimei</span></span><br><span class="line">&#125;</span><br><span class="line">setName(name);</span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">//output: lilei</span></span><br></pre></td></tr></table></figure></p>
<p>当我们将新值重新赋给变量，可以看到这里 name 值并没有改变,实际上 n 只是保存了 name 复制的一个副本(函数的形参是被调用时所传实参的副本)。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>lilei</td>
</tr>
<tr>
<td>n</td>
<td>lilei</td>
</tr>
</tbody>
</table>
<p>所以，n 的改变对 name 没有影响。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>lilei</td>
</tr>
<tr>
<td>n</td>
<td>hanmeimei</td>
</tr>
</tbody>
</table>
<p>我们把它称作值传递。<br>可以这样理解，当传递 name 到函数 setName 中，相当于拷贝了一份 name ，假设拷贝的这份叫 _name ，函数中修改的都是 _name 的值，而不会影响原来的 name 值。</p>
<p>回到最前边我们看到的那段代码，稍加改动:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span> : <span class="string">'lilei'</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// obj.name = 'hanmeimei';</span></span><br><span class="line">    obj = &#123; <span class="attr">name</span> : <span class="string">'hanmeimei'</span> &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name);  <span class="comment">//output: hanmeimei</span></span><br><span class="line">&#125;</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">//output: lilei</span></span><br></pre></td></tr></table></figure></p>
<p>所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。<br>但这里 obj 的改变并没有影响 person，这究竟是引用传递吗？</p>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>看到这，相信你对之前的理解已有了不一样的认识。<br>既然这不是引用传递，还会是值传递么？</p>
<p>基本数据类型传递值，引用数据类型传递引用地址(<strong>引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象</strong>)。</p>
<p>正如前边定义所提到的那样，值传递，<strong>函数的形参是被调用时所传实参的副本</strong>。<br>不难理解，当 person </p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>person</td>
<td>&lt;#001&gt;</td>
<td>#001</td>
<td>{ name : ‘lilei’ }</td>
</tr>
</tbody>
</table>
<p>做为参数进入函数 setName 后，就有了地址副本，这个地址副本和 person 的地址指向是相同的。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>person</td>
<td>&lt;#001&gt;</td>
<td>#001</td>
<td>{ name : ‘lilei’ }</td>
</tr>
<tr>
<td>obj</td>
<td>&lt;#001&gt;</td>
<td>#001</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;#002&gt;</td>
<td>#002</td>
<td>{ name : ‘hanmeimei’ }</td>
</tr>
</tbody>
</table>
<p>如果这个时候我们对这个副本操作改变其属性值，则指向这个地址的变量都会发生变化。<br>但我们为 obj 重新赋了值，将地址副本指向改变，指向了新的对象。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>person</td>
<td>&lt;#001&gt;</td>
<td>#001</td>
<td>{ name : ‘lilei’ }</td>
</tr>
<tr>
<td>obj</td>
<td>&lt;#002&gt;</td>
<td>#002</td>
<td>{ name : ‘hanmeimei’ }</td>
</tr>
</tbody>
</table>
<p>这样一来 obj 和 person 就完全断了， obj 的改变并不会影响 person。 </p>
<p><strong>传递对象引用的副本</strong>，这样的传递方式又被称之为共享传递(call by sharing)。<br>拷贝副本，也是一种值的拷贝，所以在JS中只有值传递。😉</p>
]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让元素里的 div 垂直居中</title>
    <url>/2017/09/08/div-vertical-center/</url>
    <content><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/09/08/div-vertical-center/header-img.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="已知宽高元素"><a href="#已知宽高元素" class="headerlink" title="已知宽高元素"></a>已知宽高元素</h2><p>绝对定位与负边距实现。利用绝对定位，将元素的top和left属性都设为50%，再利用margin边距，将元素回拉它本身高宽的一半，实现垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>: x;</span><br><span class="line">    <span class="attribute">height</span>: y;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -x / <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> -y / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="未知宽高元素"><a href="#未知宽高元素" class="headerlink" title="未知宽高元素"></a>未知宽高元素</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用绝对定位与margin。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>当要被居中的元素是内联元素的时候，将父级容器设置为display:table-cell，配合text-align:center和vertical-align:middle即可以实现水平垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>使用css3的transform。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>使用flex布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术水波文</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>居中</tag>
      </tags>
  </entry>
</search>
